using System;
using System.Collections;
using System.Collections.Generic;
using Mariana.AVM2.Native;
using Mariana.Common;

namespace Mariana.AVM2.Core {

    /// <summary>
    /// An XML object represents an XML node (element, text, attribute, comment or processing
    /// instruction) in E4X.
    /// </summary>
    [AVM2ExportClass(name = "XML", hasPrototypeMethods = true)]
    [AVM2ExportClassInternal(tag = ClassTag.XML)]
    public class ASXML : ASObject {

        private static bool s_ignoreComments = true;
        private static bool s_ignoreProcessingInstructions = true;
        private static bool s_ignoreWhitespace = true;
        private static bool s_prettyPrinting = true;
        private static int s_prettyIndent = 2;

        /// <summary>
        /// The value of the "length" property of the AS3 XML class.
        /// </summary>
        [AVM2ExportTrait(name = "length")]
        public new const int AS_length = 1;

        /// <summary>
        /// If this is set to true, whitespace at the beginning and end of text nodes is ignored
        /// during parsing.
        /// </summary>
        ///
        /// <remarks>
        /// If this is set, text nodes containing only whitespace are not created. Whitespace in CDATA
        /// sections, attributes, comments and processing instructions is always preserved regardless
        /// of this setting. The default value is true.
        /// </remarks>
        [AVM2ExportTrait]
        public static bool ignoreWhitespace {
            get => s_ignoreWhitespace;
            set => s_ignoreWhitespace = value;
        }

        /// <summary>
        /// If this is set to true, comments are ignored during parsing. The default value is true.
        /// </summary>
        [AVM2ExportTrait]
        public static bool ignoreComments {
            get => s_ignoreComments;
            set => s_ignoreComments = value;
        }

        /// <summary>
        /// If this is set to true, processing instructions are ignored during parsing. The default
        /// value is true.
        /// </summary>
        [AVM2ExportTrait]
        public static bool ignoreProcessingInstructions {
            get => s_ignoreProcessingInstructions;
            set => s_ignoreProcessingInstructions = value;
        }

        /// <summary>
        /// Set this to true to enable pretty printing. The default value is true.
        /// </summary>
        ///
        /// <remarks>
        /// If this is set to true, XML strings generated by the <c>toString()</c> and
        /// <c>toXMLString()</c> methods will output each node on a new line (except when an
        /// element has a single text node child, in which case the start tag, text and end tag will
        /// all be output on the same line). In addition, leading and trailing white space in text
        /// nodes (except for CDATA nodes) is not output. The default value is true.
        /// </remarks>
        ///
        /// <seealso cref="prettyIndent" />
        [AVM2ExportTrait]
        public static bool prettyPrinting {
            get => s_prettyPrinting;
            set => s_prettyPrinting = value;
        }

        /// <summary>
        /// If <see cref="prettyPrinting"/> is set to true, this is the number of spaces per depth
        /// level by which each node must be indented. The default value is 2.
        /// </summary>
        [AVM2ExportTrait]
        public static int prettyIndent {
            get => s_prettyIndent;
            set => s_prettyIndent = value;
        }

        private ASQName m_name;

        private XMLNodeType m_nodeType;

        private _ElementNode m_parent;

        private ASXML m_next;

        /// <summary>
        /// Creates a new XML node.
        /// </summary>
        ///
        /// <param name="name">The qualified name of the XML node.</param>
        /// <param name="parent">The parent node of the current XML node.</param>
        /// <param name="nodeType">The kind of the node represented by the current XML instance. This
        /// must be a value from the <see cref="XMLNodeType"/> enumeration.</param>
        internal ASXML(ASQName name, ASXML parent, XMLNodeType nodeType) {
            m_name = name;
            m_parent = (_ElementNode)parent;
            m_nodeType = nodeType;
        }

        /// <exclude/>
        ///
        /// <summary>
        /// This method is called internally from the AVM2 and from code compiled with the
        /// ABC to IL compiler to invoke the ActionScript XML constructor. This method must not
        /// be used by .NET code.
        /// </summary>
        internal static new ASAny __AS_INVOKE(ReadOnlySpan<ASAny> args) {
            ASAny arg = (args.Length == 0) ? ASAny.undefined : args[0];

            if (arg.value == null)
                return createNode(XMLNodeType.TEXT);

            if (arg.value is ASXML argXml)
                return argXml;

            if (arg.value is ASXMLList argXmlList)
                return fromXMLList(argXmlList, false);

            return parse(ASAny.AS_convertString(arg));
        }

        /// <exclude/>
        ///
        /// <summary>
        /// This method is called internally from the AVM2 and from code compiled with the
        /// ABC to IL compiler to invoke the ActionScript XML constructor. This method must not
        /// be used by .NET code.
        /// </summary>
        internal static new ASAny __AS_CONSTRUCT(ReadOnlySpan<ASAny> args) {
            ASAny arg = (args.Length == 0) ? ASAny.undefined : args[0];

            if (arg.value == null)
                return createNode(XMLNodeType.TEXT);

            if (arg.value is ASXML argXml)
                return argXml.copy();

            if (arg.value is ASXMLList argXmlList)
                return fromXMLList(argXmlList, true);

            return parse(ASAny.AS_convertString(arg));
        }

        internal static void __AS_CLASS_LOADED(ClassImpl klass) {
            string[] staticMethods = new[] {nameof(settings), nameof(setSettings), nameof(defaultSettings)};

            for (int i = 0; i < staticMethods.Length; i++) {
                klass.classObject.AS_dynamicProps.setValue(
                    staticMethods[i],
                    klass.getMethod(new QName(Namespace.AS3, staticMethods[i]), TraitScope.STATIC).createMethodClosure()
                );
            }
        }

        /// <inheritdoc/>
        // XML to string conversions should ignore any overridden XML.prototype.toString method
        protected override string AS_coerceString() => AS_toString();

        /// <summary>
        /// Converts an XMLList instance into an XML instance. For an XMLList with exactly one
        /// item, that item is returned.
        /// </summary>
        /// <returns>The XML instance. If <paramref name="xmlList"/> is null, returns an
        /// empty text node.</returns>
        /// <param name="xmlList">An XMLList object to convert to XML.</param>
        /// <param name="copy">If set to true, return a copy of the item of the XMLList
        /// instead of that node itself.</param>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item><description>TypeError #1086: <paramref name="xmlList"/> does not have exactly one element.</description></item>
        /// </list>
        /// </exception>
        public static ASXML fromXMLList(ASXMLList xmlList, bool copy = false) {
            if (xmlList == null)
                return createNode(XMLNodeType.TEXT);
            if (xmlList.length() != 1)
                throw ErrorHelper.createError(ErrorCode.XML_LIST_METHOD_ONE_ITEM_ONLY, "XML");
            return copy ? xmlList[0].copy() : xmlList[0];
        }

        /// <summary>
        /// Returns a deep copy of the given XML node.
        /// </summary>
        /// <param name="node">The XML node for which to create a deep copy.</param>
        /// <returns>A deep copy of <paramref name="node"/>, or an empty text node if
        /// <paramref name="node"/> is null.</returns>
        public static ASXML copy(ASXML node) => (node != null) ? node.copy() : createNode(XMLNodeType.TEXT);

        /// <summary>
        /// Returns an object with the following properties: ignoreWhitespace,
        /// ignoreProcessingInstructions, ignoreComments, prettyPrint and prettyIndent. The values of
        /// these properties are set to the default values of the corresponding static fields of the
        /// <see cref="ASXML"/> class.
        /// </summary>
        ///
        /// <returns>An object with properties whose values are the default values for the XML class
        /// static fields.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        public static ASObject defaultSettings() {
            ASObject obj = new ASObject();
            DynamicPropertyCollection props = obj.AS_dynamicProps;
            props[nameof(ignoreWhitespace)] = true;
            props[nameof(ignoreProcessingInstructions)] = true;
            props[nameof(ignoreComments)] = true;
            props[nameof(prettyPrinting)] = true;
            props[nameof(prettyIndent)] = 2;
            return obj;
        }

        /// <summary>
        /// Returns an object with the following properties: ignoreWhitespace,
        /// ignoreProcessingInstructions, ignoreComments, prettyPrint and prettyIndent. The values of
        /// these properties are set to the current values of the corresponding static fields of the
        /// XML class.
        /// </summary>
        ///
        /// <returns>An object with properties whose values are the current values of the XML class
        /// static fields.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        public static ASObject settings() {
            ASObject obj = new ASObject();
            DynamicPropertyCollection props = obj.AS_dynamicProps;
            props[nameof(ignoreWhitespace)] = ignoreWhitespace;
            props[nameof(ignoreProcessingInstructions)] = ignoreProcessingInstructions;
            props[nameof(ignoreComments)] = ignoreComments;
            props[nameof(prettyPrinting)] = prettyPrinting;
            props[nameof(prettyIndent)] = prettyIndent;
            return obj;
        }

        /// <summary>
        /// Sets the values of the following static fields to the corresponding properties of the
        /// given object: ignoreWhitespace, ignoreProcessingInstructions, ignoreComments, prettyPrint
        /// and prettyIndent. This method can also be used to restore the default values of these
        /// fields.
        /// </summary>
        ///
        /// <param name="obj">The object whose properties are to be set to the corresponding static
        /// fields of the XML class. If this is null, the static fields will be set to their default
        /// values.</param>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        public static void setSettings(ASObject obj = null) {
            if (obj == null) {
                ignoreWhitespace = true;
                ignoreProcessingInstructions = true;
                ignoreComments = true;
                prettyPrinting = true;
                prettyIndent = 2;
            }
            else {
                ASAny propValue;

                if (obj.AS_tryGetProperty(nameof(ignoreWhitespace), out propValue) == BindStatus.SUCCESS)
                    ignoreWhitespace = (bool)propValue;

                if (obj.AS_tryGetProperty(nameof(ignoreProcessingInstructions), out propValue) == BindStatus.SUCCESS)
                    ignoreProcessingInstructions = (bool)propValue;

                if (obj.AS_tryGetProperty(nameof(ignoreComments), out propValue) == BindStatus.SUCCESS)
                    ignoreComments = (bool)propValue;

                if (obj.AS_tryGetProperty(nameof(prettyPrinting), out propValue) == BindStatus.SUCCESS)
                    prettyPrinting = (bool)propValue;

                if (obj.AS_tryGetProperty(nameof(prettyIndent), out propValue) == BindStatus.SUCCESS)
                    prettyIndent = (int)propValue;
            }
        }

        /// <summary>
        /// Creates a new node of the given kind with the given name.
        /// </summary>
        ///
        /// <param name="nodeType">The type of node to create This can be any value of
        /// <see cref="XMLNodeType"/> other than
        /// <see cref="XMLNodeType.ATTRIBUTE" qualifyHint="true"/>. If this is any value other than
        /// <see cref="XMLNodeType.ELEMENT" qualifyHint="true"/>, the node value will be initialized
        /// to the empty string.</param>
        /// <param name="nodeName">The name of the node. For text and comment nodes, the name need not
        /// be specified and is ignored. A name is required for all other node types.</param>
        /// <param name="nodeText">The value to be set for a text node. If
        /// <paramref name="nodeType"/> is <see cref="XMLNodeType.ELEMENT" qualifyHint="true"/>,
        /// this argument is ignored.</param>
        ///
        /// <returns>The created node. If <paramref name="nodeType"/> is
        /// <see cref="XMLNodeType.ELEMENT" qualifyHint="true"/> or
        /// <see cref="XMLNodeType.PROCESSING_INSTRUCTION" qualifyHint="true"/>, and the local name
        /// of <paramref name="nodeName"/> is not a valid XML name, returns null.</returns>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item>
        /// <description>ArgumentError #10061: <paramref name="nodeType"/> is not a valid value for this method (this
        /// includes <see cref="XMLNodeType.ATTRIBUTE" qualifyHint="true"/>)</description>
        /// </item>
        /// </list>
        /// </exception>
        public static ASXML createNode(XMLNodeType nodeType, ASQName nodeName = null, string nodeText = null) {
            if (nodeType == XMLNodeType.ELEMENT || nodeType == XMLNodeType.PROCESSING_INSTRUCTION) {
                if (nodeName == null || !XMLHelper.isValidName(nodeName.localName))
                    return null;
            }

            ASXML node;

            switch (nodeType) {
                case XMLNodeType.ELEMENT:
                    if (nodeName.uri == null)
                        nodeName = new ASQName(ASNamespace.getDefault(), nodeName.localName);
                    node = new _ElementNode(nodeName, null);
                    if (nodeName.prefix != null && nodeName.uri.Length != 0)
                        node.addNamespace(nodeName.getNamespace());
                    break;

                case XMLNodeType.TEXT:
                case XMLNodeType.COMMENT:
                case XMLNodeType.CDATA:
                    node = new _TextNode(null, null, nodeType, nodeText);
                    break;

                case XMLNodeType.PROCESSING_INSTRUCTION:
                    if (nodeName.uri == null || nodeName.uri.Length != 0)
                        nodeName = new ASQName("", nodeName.localName);
                    node = new _TextNode(nodeName, null, XMLNodeType.PROCESSING_INSTRUCTION, nodeText);
                    break;

                default:
                    throw ErrorHelper.createError(ErrorCode.MARIANA__ARGUMENT_OUT_OF_RANGE, nameof(nodeType));
            }

            return node;
        }

        /// <summary>
        /// Returns an escaped string suitable for use as the value of an XML text node.
        /// </summary>
        /// <param name="str">The string to escape.</param>
        /// <returns>The escaped string.</returns>
        ///
        /// <remarks>
        /// The following characters are escaped: <c>&lt;</c>, <c>&amp;</c> and <c>&gt;</c>.
        /// </remarks>
        public static string escapeText(string str) => XMLHelper.escape(str, 0, str.Length, false);

        /// <summary>
        /// Returns an escaped string suitable for use as the value of an XML attribute.
        /// </summary>
        /// <param name="str">The string to escape.</param>
        /// <returns>The escaped string.</returns>
        ///
        /// <remarks>
        /// <para>The following characters are escaped: <c>&lt;</c>, <c>&amp;</c>, <c>&quot;</c>,
        /// 0x09 (tab), 0x0A (newline) and 0x0D (carriage return).</para>
        /// <para>This function escapes strings for double-quoted attributes. (The <c>&apos;</c>
        /// character is not escaped.)</para>
        /// </remarks>
        public static string escapeAttribute(string str) => XMLHelper.escape(str, 0, str.Length, true);

        /// <summary>
        /// Parses an XML string and returns the created <see cref="ASXML"/> object.
        /// </summary>
        /// <param name="xmlStr">The XML string to parse.</param>
        /// <returns>The <see cref="ASXML"/> instance created by parsing the string.</returns>
        public static ASXML parse(string xmlStr) {
            if (xmlStr == null)
                return createNode(XMLNodeType.TEXT);
            XMLParser parser = new XMLParser();
            return parser.parseSingleElement(xmlStr);
        }

        /// <summary>
        /// Performs an equality test on two XML nodes, using the definition of the weak equality (==)
        /// operator defined in ECMA-357.
        /// </summary>
        /// <param name="node1">The first node.</param>
        /// <param name="node2">The second node.</param>
        /// <returns>True if the two nodes are equal, otherwise false.</returns>
        ///
        /// <remarks>
        /// If one of the nodes is a text or attribute node and the other has simple content, the
        /// nodes are converted to strings and the converted strings are compared. Otherwise, the two
        /// nodes are compared using the <see cref="deepEquals"/> method. However, comparison of any
        /// descendant elements is always done using the <see cref="deepEquals"/> method, even if
        /// they have simple content.
        /// </remarks>
        public static bool AS_weakEq(ASXML node1, ASXML node2) {
            if (node1 == node2)
                return true;

            if (node1 == null)
                return node2.hasSimpleContent() && node2.internalSimpleToString() == "null";

            if (node2 == null)
                return node1.hasSimpleContent() && node1.internalSimpleToString() == "null";

            if (node1.hasSimpleContent() && (node2.isTextOrCDATA || node2.isAttribute))
                return node1.internalSimpleToString() == node2.nodeText;

            if (node2.hasSimpleContent() && (node1.isTextOrCDATA || node1.isAttribute))
                return node2.internalSimpleToString() == node1.nodeText;

            return deepEquals(node1, node2);
        }

        /// <summary>
        /// Performs a value equality comparison on two nodes. This method checks the node name and
        /// type, and text values (for non-element nodes) or attributes and child nodes (for element
        /// nodes).
        /// </summary>
        ///
        /// <param name="node1">The first node.</param>
        /// <param name="node2">The second node.</param>
        /// <returns>True if the two nodes are equal, otherwise false.</returns>
        public static bool deepEquals(ASXML node1, ASXML node2) {
            if (node1 == node2)
                return true;
            if (node1 == null || node2 == null)
                return false;

            var iter1 = node1.getDescendantEnumerator(true);
            var iter2 = node2.getDescendantEnumerator(true);

            while (true) {
                bool hasNext1 = iter1.MoveNext(), hasNext2 = iter2.MoveNext();
                if (!hasNext1 || !hasNext2)
                    return hasNext1 == hasNext2;
                if (iter1.currentDepth != iter2.currentDepth || !shallowEquals(iter1.Current, iter2.Current))
                    return false;
            }

            bool shallowEquals(ASXML x, ASXML y) {
                if (x.m_nodeType != y.m_nodeType)
                    return false;

                // The name field is always null for nodes without names (such as text nodes)
                // so the name check will always pass for those nodes.
                if (!ASQName.AS_equals(x.m_name, y.m_name))
                    return false;

                return x.isElement ? compareAttributes(x, y) : x.nodeText == y.nodeText;
            }

            bool compareAttributes(ASXML x, ASXML y) {
                // Check that:
                // - The number of attributes in both x and y are the same
                // - For every attribute in x, there is an attribute in y with the same name and the
                //   values of the two attributes are equal.
                // This is an O(N^2) search, but most real-world XML documents don't have elements with a
                // number of attributes large enough for this to be a bottleneck.

                var xFirstAttr = x.internalGetFirstAttr();
                var yFirstAttr = y.internalGetFirstAttr();

                ASXML xCurAttr = xFirstAttr;
                ASXML yCurAttr = yFirstAttr;

                while (xCurAttr != null && yCurAttr != null)
                    (xCurAttr, yCurAttr) = (xCurAttr.m_next, yCurAttr.m_next);

                if (xCurAttr != null || yCurAttr != null) {
                    // Number of attributes is different.
                    return false;
                }

                xCurAttr = xFirstAttr;

                while (xCurAttr != null) {
                    yCurAttr = yFirstAttr;

                    while (yCurAttr != null && !ASQName.AS_equals(xCurAttr.m_name, yCurAttr.m_name))
                        yCurAttr = yCurAttr.m_next;

                    if (yCurAttr == null || xCurAttr.nodeText != yCurAttr.nodeText)
                        return false;

                    xCurAttr = xCurAttr.m_next;
                }

                return true;
            }
        }

        #region Internal methods

        // These methods are overridden for element nodes.

        /// <exclude/>
        ///
        /// <summary>
        /// Gets the first child node of this node.
        /// </summary>
        /// <returns>The first child of this node, or null if this node has no children.</returns>
        protected virtual ASXML internalGetFirstChild() => null;

        /// <exclude/>
        ///
        /// <summary>
        /// Gets the last child node of this node.
        /// </summary>
        /// <returns>The last child of this node, or null if this node has no children.</returns>
        protected virtual ASXML internalGetLastChild() => null;

        /// <exclude/>
        ///
        /// <summary>
        /// Gets the first attribute of this node.
        /// </summary>
        /// <returns>The first attribute of this node, or null if this node has no attributes.</returns>
        protected virtual ASXML internalGetFirstAttr() => null;

        /// <exclude/>
        ///
        /// <summary>
        /// Finds a namespace prefix for the given name.
        /// </summary>
        /// <returns>A namespace prefix, or null if no prefix is available in the node's context.</returns>
        /// <param name="name">The qualified name for which to find a prefix.</param>
        /// <param name="isAttr">Set this to true if <paramref name="name"/> is the name of an
        /// attribute, otherwise set to false.</param>
        protected virtual string internalFindPrefixForName(ASQName name, bool isAttr) =>
            m_parent.internalFindPrefixForName(name, isAttr);

        /// <summary>
        /// Gets the qualified name of this node.
        /// </summary>
        /// <returns>The qualified name of this node. It is unspecified whether the qualified name
        /// will have a prefix or not. (The <see cref="name"/> method, on the other hand, will
        /// return a name with a prefix if one is available in the node's context.)</returns>
        internal ASQName internalGetName() => m_name;

        /// <summary>
        /// Inserts a new child node after another node.
        /// </summary>
        /// <returns>The node inserted into the child list of this node. If <paramref name="mustCopy"/>
        /// is true, the copy of <paramref name="node"/> that was inserted is returned; otherwise,
        /// <paramref name="node"/> itself is returned.</returns>
        /// <param name="prevNode">The node after which to insert <paramref name="node"/>. To
        /// insert at the beginning, set this to null.</param>
        /// <param name="node">The node to insert after <paramref name="prevNode"/>.</param>
        /// <param name="mustCopy">If set to true, make a deep copy of <paramref name="node"/> and
        /// insert that copy. Otherwise insert <paramref name="node"/> itself.</param>
        internal virtual ASXML internalInsertChildAfter(ASXML prevNode, ASXML node, bool mustCopy) => null;

        /// <summary>
        /// Inserts a list of child nodes after another node.
        /// </summary>
        /// <param name="prevNode">The node after which to insert <paramref name="list"/>. To
        /// insert at the beginning, set this to null.</param>
        /// <param name="list">The list of nodes to insert after <paramref name="prevNode"/>.</param>
        /// <param name="mustCopy">If set to true, make a deep copy of each node in <paramref name="list"/>
        /// and insert that copy. Otherwise insert the nodes in <paramref name="list"/> directly.</param>
        internal virtual void internalInsertChildrenAfter(ASXML prevNode, ASXMLList list, bool mustCopy) { }

        /// <summary>
        /// Sets the property of this XML instance with the given generalized name.
        /// </summary>
        /// <param name="genName">A reference to a generalized name (<see cref="XMLGenName"/>
        /// instance).</param>
        /// <param name="value">The value to assign to the property with the name
        /// <paramref name="genName"/>.</param>
        internal virtual void internalSetPropGenName(in XMLGenName genName, ASAny value) { }

        /// <summary>
        /// Deletes the property of this XML instance with the given generalized name.
        /// </summary>
        /// <param name="genName">A reference to a generalized name (<see cref="XMLGenName"/>
        /// instance).</param>
        internal virtual void internalDeletePropGenName(in XMLGenName genName) { }

        /// <summary>
        /// Deletes all children from an element node.
        /// </summary>
        internal virtual void internalClearChildren() { }

        /// <summary>
        /// Deletes the given child or attribute from this node.
        /// </summary>
        /// <param name="child">The child node or attribute to delete. If this is not a child
        /// or attribute of this node, this method does nothing.</param>
        internal virtual void internalDeleteChildOrAttr(ASXML child) { }

        /// <summary>
        /// Replaces a child node of this node with another.
        /// </summary>
        /// <returns>The node inserted into the child list of this node. If <paramref name="mustCopy"/>
        /// is true, the copy of <paramref name="newChild"/> that was inserted is returned; otherwise,
        /// <paramref name="newChild"/> itself is returned.</returns>
        /// <param name="child">The child node to be replaced with <paramref name="newChild"/>.
        /// If this is null or not a child of this node, <paramref name="newChild"/> is
        /// appended.</param>
        /// <param name="newChild">The new child to be inserted into the child list of this node,
        /// in place of <paramref name="child"/>.</param>
        /// <param name="mustCopy">If set to true, make a deep copy of <paramref name="newChild"/>
        /// and insert that copy. Otherwise insert <paramref name="newChild"/> itself.</param>
        internal virtual ASXML internalReplaceChild(ASXML child, ASXML newChild, bool mustCopy) => null;

        /// <summary>
        /// Replaces a child node of this node with nodes from an array.
        /// </summary>
        /// <param name="child">The child node to remove from this node's child list. If this
        /// is null or not a child of this node, the new children are appended.</param>
        /// <param name="newChildren">A span containing the new children to be inserted.</param>
        /// <param name="mustCopy">If this is set to true, makes a deep copy of each node in
        /// <paramref name="newChildren"/> and insert the copied children. The elements
        /// of <paramref name="newChildren"/> will also be set to their copies which were inserted.</param>
        internal virtual void internalReplaceChild(ASXML child, Span<ASXML> newChildren, bool mustCopy) { }

        /// <summary>
        /// Appends the namespace declarations of this node to the given list.
        /// </summary>
        /// <param name="list">The list to which to append the namespace declarations.</param>
        /// <remarks>
        /// When this method is called, <paramref name="list"/> contains all the namespace
        /// declarations from the node's parent context, in the correct order (starting from
        /// the root). This method must not append a namespace prefix declaration if one or more
        /// declarations with that prefix exists in <paramref name="list"/>, and the last such
        /// declaration has the same URI.
        /// </remarks>
        internal virtual void internalGetNamespaceDecls(ref DynamicArray<ASNamespace> list) { }

        /// <summary>
        /// Finds an attribute or child node that matches a generalized XML name.
        /// </summary>
        /// <param name="genName">A generalized XML name. This must not represent an index.</param>
        /// <returns>If a node matching <paramref name="genName"/> was found, returns that node.
        /// Otherwise, returns null.</returns>
        internal ASXML internalFindNodeByGenName(in XMLGenName genName) {
            ASXML curNode = genName.isAttr ? internalGetFirstAttr() : internalGetFirstChild();

            bool isAnyNamespace = genName.uri == null;
            string localName = genName.localName;

            XMLNodeType targetType = genName.isAttr ? XMLNodeType.ATTRIBUTE : XMLNodeType.ELEMENT;

            if (genName.isMultiname) {
                // For multiname lookup.

                if (genName.nsSet.containsAny) {
                    isAnyNamespace = true;
                }
                else {
                    if (!genName.nsSet.contains(NamespaceKind.NAMESPACE))
                        return null;

                    for (; curNode != null; curNode = curNode.m_next) {
                        ASQName nodeName = curNode.m_name;

                        if (targetType == curNode.m_nodeType
                            && (localName == null || localName == nodeName.localName)
                            && (genName.nsSet.contains(nodeName.uri) || nodeName.uri == genName.uri))
                        {
                            return curNode;
                        }
                    }

                    return null;
                }
            }

            if (isAnyNamespace && localName == null)
                return curNode;

            for (; curNode != null; curNode = curNode.m_next) {
                ASQName nodeName = curNode.m_name;

                if (targetType == curNode.m_nodeType
                    && (localName == null || localName == nodeName.localName)
                    && (isAnyNamespace || genName.uri == nodeName.uri))
                {
                    return curNode;
                }
            }

            return null;
        }

        /// <summary>
        /// Appends all attributes or children of this node matching a generalized XML name
        /// (XMLGenName) to the given list.
        /// </summary>
        /// <param name="genName">A generalized XML name. This must not represent an index.</param>
        /// <param name="outList">The list to which to append the nodes matching the given generalized
        /// name.</param>
        internal void internalFetchNodesByGenName(in XMLGenName genName, ref DynamicArray<ASXML> outList) {
            ASXML curNode = genName.isAttr ? internalGetFirstAttr() : internalGetFirstChild();

            bool isAnyNamespace = genName.uri == null;
            string localName = genName.localName;

            XMLNodeType targetType;
            if (genName.isAttr)
                targetType = XMLNodeType.ATTRIBUTE;
            else if (genName.isProcInstr)
                targetType = XMLNodeType.PROCESSING_INSTRUCTION;
            else
                targetType = XMLNodeType.ELEMENT;

            if (genName.isMultiname) {
                // For multiname lookup.

                if (genName.nsSet.containsAny) {
                    isAnyNamespace = true;
                }
                else {
                    if (!genName.nsSet.contains(NamespaceKind.NAMESPACE))
                        return;

                    for (; curNode != null; curNode = curNode.m_next) {
                        ASQName nodeName = curNode.m_name;

                        if (targetType == curNode.m_nodeType
                            && (localName == null || localName == nodeName.localName)
                            && (genName.nsSet.contains(nodeName.uri) || nodeName.uri == genName.uri))
                        {
                            outList.add(curNode);
                        }
                    }
                    return;
                }
            }

            if (isAnyNamespace && localName == null && !genName.isProcInstr) {
                // Special case for the "any" name. This must match ALL nodes from
                // the element/attribute list irrespective of their type.
                for (; curNode != null; curNode = curNode.m_next)
                    outList.add(curNode);
                return;
            }

            for (; curNode != null; curNode = curNode.m_next) {
                ASQName nodeName = curNode.m_name;

                if (targetType == curNode.m_nodeType
                    && (localName == null || localName == nodeName.localName)
                    && (isAnyNamespace || genName.uri == nodeName.uri))
                {
                    outList.add(curNode);
                }
            }
        }

        /// <summary>
        /// Appends all attributes or child nodes having the given node type to the given list.
        /// </summary>
        /// <param name="nodeType">The node type.</param>
        /// <param name="outList">The list to which the nodes will be appended to.</param>
        internal void internalFetchNodesByType(XMLNodeType nodeType, ref DynamicArray<ASXML> outList) {
            ASXML curNode = (nodeType == XMLNodeType.ATTRIBUTE) ? internalGetFirstAttr() : internalGetFirstChild();
            for (; curNode != null; curNode = curNode.m_next) {
                if (curNode.m_nodeType == nodeType)
                    outList.add(curNode);
            }
        }

        /// <summary>
        /// Appends all descendants of this node matching a generalized XML name (XMLGenName) to the
        /// given list.
        /// </summary>
        /// <param name="genName">A generalized XML name. This must not represent an index.</param>
        /// <param name="outList">The list to which to append the descendant nodes matching the given
        /// generalized name.</param>
        internal void internalFetchDescByGenName(in XMLGenName genName, ref DynamicArray<ASXML> outList) {
            if (genName.isAttr || genName.isProcInstr) {
                internalFetchNodesByGenName(genName, ref outList);
                return;
            }

            bool isAnyNamespace = genName.uri == null;
            string localName = genName.localName;

            var enumerator = getDescendantEnumerator();

            if (genName.isMultiname) {
                if (genName.nsSet.containsAny) {
                    isAnyNamespace = true;
                }
                else {
                    if (!genName.nsSet.contains(NamespaceKind.NAMESPACE))
                        return;

                    foreach (ASXML cur in enumerator) {
                        ASQName nodeName = cur.m_name;

                        if (cur.isElement
                            && (localName == null || localName == nodeName.localName)
                            && (genName.nsSet.contains(nodeName.uri) || nodeName.uri == genName.uri))
                        {
                            outList.add(cur);
                        }
                    }

                    return;
                }
            }

            if (isAnyNamespace && localName == null) {
                // For the special case of the "any" name, we must match both elements and non-elements.
                foreach (ASXML cur in enumerator)
                    outList.add(cur);
                return;
            }

            foreach (ASXML cur in enumerator) {
                ASQName nodeName = cur.m_name;

                if (cur.isElement
                    && (localName == null || localName == nodeName.localName)
                    && (isAnyNamespace || genName.uri == nodeName.uri))
                {
                    outList.add(cur);
                }
            }
        }

        /// <summary>
        /// Returns a string representation of an XML node having simple content.
        /// </summary>
        /// <returns>The string representation of the node.</returns>
        internal string internalSimpleToString() {
            if (m_nodeType != XMLNodeType.ELEMENT)
                return nodeText;

            ASXML firstChild = internalGetFirstChild();

            if (firstChild == null)
                return "";

            if (firstChild.m_next == null)
                return firstChild.isTextOrCDATA ? firstChild.nodeText : "";

            var textList = new DynamicArray<string>();
            for (ASXML cur = firstChild; cur != null; cur = cur.m_next) {
                if (cur.isTextOrCDATA)
                    textList.add(cur.nodeText);
            }

            if (textList.length == 1)
                return textList[0];

            return String.Join("", textList.getUnderlyingArray(), 0, textList.length);
        }

        /// <summary>
        /// Internal function for creating an element.
        /// </summary>
        /// <returns>The created element node.</returns>
        internal static ASXML internalCreateElement(
            ASQName name, ReadOnlySpan<ASXML> attrs, ReadOnlySpan<ASXML> children, ASNamespace[] nsDecls)
        {
            ASXML firstAttr = null, firstChild = null;
            ref ASXML attrTail = ref firstAttr;
            ref ASXML childTail = ref firstChild;

            for (int i = 0; i < attrs.Length; i++) {
                attrTail = attrs[i];
                attrTail = ref attrTail.m_next;
            }

            for (int i = 0; i < children.Length; i++) {
                childTail = children[i];
                childTail = ref childTail.m_next;
            }

            ASXML lastChild = (children.Length > 0) ? children[children.Length - 1] : null;

            var elem = new _ElementNode(name, null, firstAttr, firstChild, lastChild, nsDecls);

            for (int i = 0; i < attrs.Length; i++)
                attrs[i].m_parent = elem;

            for (int i = 0; i < children.Length; i++)
                children[i].m_parent = elem;

            return elem;
        }

        /// <summary>
        /// Internal function for creating an attribute.
        /// </summary>
        /// <returns>The created attribute.</returns>
        internal static ASXML internalCreateAttribute(ASQName name, string value) =>
            new _TextNode(name, null, XMLNodeType.ATTRIBUTE, value);

        /// <summary>
        /// Checks whether the given name can be used as the name of an attribute of this node.
        /// </summary>
        /// <param name="attrName">The name of the attribute.</param>
        /// <param name="existingAttr">If an attribute with the name <paramref name="attrName"/> is
        /// already defined on this element, pass it as this argument. This is used when changing the
        /// name of an existing attribute.</param>
        /// <returns>True if it is OK to use the name, false otherwise.</returns>
        ///
        /// <remarks>
        /// This function checks for the following names: the name having the empty URI and the local
        /// name "xmlns", and names of attributes already defined on this element (except for
        /// <paramref name="existingAttr"/>, if that is specified)
        /// </remarks>
        private bool _checkAttributeName(ASQName attrName, ASXML existingAttr = null) {
            if (attrName.uri.Length == 0 && attrName.localName == "xmlns")
                return false;

            for (ASXML cur = internalGetFirstAttr(); cur != null; cur = cur.m_next) {
                if (cur != existingAttr
                    && cur.m_name.localName == attrName.localName
                    && cur.m_name.uri == attrName.uri)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Finds a namespace in <paramref name="span"/> having the prefix <paramref name="prefix"/>.
        /// </summary>
        /// <param name="span">The span of namespaces in which to search for the prefix.</param>
        /// <param name="prefix">The prefix to search for.</param>
        /// <returns>The index of the namespace in <paramref name="span"/>, or -1 if no namespace
        /// with the prefix <paramref name="prefix"/> was found.</returns>
        private static int _findNamespaceByPrefix(ReadOnlySpan<ASNamespace> span, string prefix) {
            for (int i = 0; i < span.Length; i++) {
                if (span[i]?.prefix == prefix)
                    return i;
            }
            return -1;
        }

        /// <summary>
        /// Checks if the given argument is an XML node that is a child of the this node, or
        /// a single-element XMLList containing a child of this node, and returns that child
        /// node.
        /// </summary>
        /// <param name="child">The argument to check.</param>
        /// <returns>If <paramref name="child"/> is a child of this node, returns the node;
        /// if it is an XMLList containing a child, returns the child in the list; otherwise
        /// returns null.</returns>
        private ASXML _checkChildOfCurrentNode(ASAny child) {
            ASXML childNode = child.value as ASXML;

            if (childNode == null && child.value is ASXMLList xmlList && xmlList.length() == 1)
                childNode = xmlList[0];

            if (childNode != null && childNode.m_parent == this && childNode.m_nodeType != XMLNodeType.ATTRIBUTE)
                return childNode;

            return null;
        }

        #endregion

        #region Property binding methods

        /// <inheritdoc/>
        public override bool AS_hasProperty(
            in QName name,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;
            if (name.ns.kind != NamespaceKind.NAMESPACE && name.ns.kind != NamespaceKind.ANY)
                return false;

            var genName = XMLGenName.fromQName(name, options);

            if (genName.isIndex)
                return genName.index == 0;

            return internalFindNodeByGenName(genName) != null;
        }

        /// <inheritdoc/>
        public override bool AS_hasProperty(
            string name, in NamespaceSet nsSet,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;

            var genName = XMLGenName.fromMultiname(name, nsSet, options);

            if (genName.isIndex)
                return genName.index == 0;

            return internalFindNodeByGenName(genName) != null;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetProperty(
            in QName name, out ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            value = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromQName(name, options);

            if (name.ns.kind != NamespaceKind.NAMESPACE && name.ns.kind != NamespaceKind.ANY) {
                value = new ASXMLList(Array.Empty<ASXML>(), 0, true, this, genName.isAttr);
                return BindStatus.SUCCESS;
            }

            if (genName.isIndex) {
                value = (genName.index == 0) ? this : default(ASAny);
                return BindStatus.SUCCESS;
            }

            var list = new DynamicArray<ASXML>(genName.isAttr ? 1 : 0);
            internalFetchNodesByGenName(genName, ref list);

            value = new ASXMLList(
                list.getUnderlyingArray(), list.length, noCopy: true, targetObject: this, targetName: genName);

            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetProperty(
            string name, in NamespaceSet nsSet, out ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            value = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromMultiname(name, nsSet, options);

            if (genName.isIndex) {
                value = (genName.index == 0) ? this : default(ASAny);
                return BindStatus.SUCCESS;
            }

            var list = new DynamicArray<ASXML>(genName.isAttr ? 1 : 0);
            internalFetchNodesByGenName(genName, ref list);

            value = new ASXMLList(
                list.getUnderlyingArray(), list.length, noCopy: true, targetObject: this, targetName: genName);

            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_trySetProperty(
            in QName name, ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromQName(name, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalSetPropGenName(genName, value);
            return BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_trySetProperty(
            string name, in NamespaceSet nsSet, ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromMultiname(name, nsSet, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalSetPropGenName(genName, value);
            return BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryCallProperty(
            in QName name, ReadOnlySpan<ASAny> args, out ASAny result,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            // See ECMA-357, sec. 11.2.2.1 (CallMethod)
            BindStatus bindStatus = base.AS_tryCallProperty(name, args, out result, options);
            if (bindStatus == BindStatus.NOT_FOUND && hasSimpleContent()) {
                string str = internalSimpleToString();
                return ASObject.AS_fromString(str).AS_tryCallProperty(name, args, out result, options);
            }
            return bindStatus;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryCallProperty(
            string name, in NamespaceSet nsSet, ReadOnlySpan<ASAny> args, out ASAny result,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            // See ECMA-357, sec. 11.2.2.1 (CallMethod)
            BindStatus bindStatus = base.AS_tryCallProperty(name, nsSet, args, out result, options);
            if (bindStatus == BindStatus.NOT_FOUND && hasSimpleContent()) {
                string str = internalSimpleToString();
                return ASObject.AS_fromString(str).AS_tryCallProperty(name, nsSet, args, out result, options);
            }
            return bindStatus;
        }

        /// <inheritdoc/>
        public override bool AS_deleteProperty(
            in QName name, BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;

            var genName = XMLGenName.fromQName(name, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalDeletePropGenName(genName);
            return true;
        }

        /// <inheritdoc/>
        public override bool AS_deleteProperty(
            string name, in NamespaceSet nsSet,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;

            var genName = XMLGenName.fromMultiname(name, nsSet, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalDeletePropGenName(genName);
            return true;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetDescendants(
            in QName name, out ASAny result, BindOptions options = BindOptions.SEARCH_DYNAMIC)
        {
            result = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            if (name.ns.kind != NamespaceKind.NAMESPACE && name.ns.kind != NamespaceKind.ANY) {
                result = new ASXMLList();
                return BindStatus.SUCCESS;
            }

            var genName = XMLGenName.fromQName(name, options);

            if (genName.isIndex) {
                result = new ASXMLList();
                return BindStatus.SUCCESS;
            }

            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchDescByGenName(genName, ref list);

            result = new ASXMLList(list.getUnderlyingArray(), list.length, noCopy: true);
            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetDescendants(
            string name, in NamespaceSet nsSet, out ASAny result, BindOptions options = BindOptions.SEARCH_DYNAMIC)
        {
            result = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromMultiname(name, nsSet, options);

            if (genName.isIndex) {
                result = new ASXMLList();
                return BindStatus.SUCCESS;
            }

            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchDescByGenName(genName, ref list);

            result = new ASXMLList(list.getUnderlyingArray(), list.length, noCopy: true);
            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override bool AS_hasPropertyObj(
            ASAny key,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;

            var genName = XMLGenName.fromObject(key, options);

            if (genName.isIndex)
                return genName.index == 0;

            return internalFindNodeByGenName(genName) != null;
        }

        /// <inheritdoc/>
        public override bool AS_hasPropertyObj(
            ASAny key, in NamespaceSet nsSet,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;

            var genName = XMLGenName.fromObjectMultiname(key, nsSet, options);

            if (genName.isIndex)
                return genName.index == 0;

            return internalFindNodeByGenName(genName) != null;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetPropertyObj(
            ASAny key, out ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            value = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromObject(key, options);

            if (genName.isIndex) {
                value = (genName.index == 0) ? this : default(ASAny);
                return BindStatus.SUCCESS;
            }

            var list = new DynamicArray<ASXML>(genName.isAttr ? 1 : 0);
            internalFetchNodesByGenName(genName, ref list);

            value = new ASXMLList(
                list.getUnderlyingArray(), list.length, noCopy: true, targetObject: this, targetName: genName);

            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetPropertyObj(
            ASAny key, in NamespaceSet nsSet, out ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC | BindOptions.SEARCH_PROTOTYPE)
        {
            value = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromObjectMultiname(key, nsSet, options);

            if (genName.isIndex) {
                value = (genName.index == 0) ? this : default(ASAny);
                return BindStatus.SUCCESS;
            }

            var list = new DynamicArray<ASXML>(genName.isAttr ? 1 : 0);
            internalFetchNodesByGenName(genName, ref list);

            value = new ASXMLList(
                list.getUnderlyingArray(), list.length, noCopy: true, targetObject: this, targetName: genName);

            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_trySetPropertyObj(
            ASAny key, ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromObject(key, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalSetPropGenName(genName, value);
            return BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_trySetPropertyObj(
            ASAny key, in NamespaceSet nsSet, ASAny value,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromObjectMultiname(key, nsSet, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalSetPropGenName(genName, value);
            return BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override bool AS_deletePropertyObj(
            ASAny key, BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;

            var genName = XMLGenName.fromObject(key, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalDeletePropGenName(genName);
            return true;
        }

        /// <inheritdoc/>
        public override bool AS_deletePropertyObj(
            ASAny key, in NamespaceSet nsSet,
            BindOptions options = BindOptions.SEARCH_TRAITS | BindOptions.SEARCH_DYNAMIC)
        {
            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return false;

            var genName = XMLGenName.fromObjectMultiname(key, nsSet, options);

            if (genName.isIndex)
                throw ErrorHelper.createError(ErrorCode.XML_ASSIGN_INDEX);

            internalDeletePropGenName(genName);
            return true;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetDescendantsObj(
            ASAny key, out ASAny result, BindOptions options = BindOptions.SEARCH_DYNAMIC)
        {
            result = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromObject(key, options);

            if (genName.isIndex) {
                result = new ASXMLList();
                return BindStatus.SUCCESS;
            }

            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchDescByGenName(genName, ref list);

            result = new ASXMLList(list.getUnderlyingArray(), list.length, noCopy: true);
            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override BindStatus AS_tryGetDescendantsObj(
            ASAny key, in NamespaceSet nsSet, out ASAny result, BindOptions options = BindOptions.SEARCH_DYNAMIC)
        {
            result = default(ASAny);

            if ((options & BindOptions.SEARCH_DYNAMIC) == 0)
                return BindStatus.NOT_FOUND;

            var genName = XMLGenName.fromObjectMultiname(key, nsSet, options);

            if (genName.isIndex) {
                result = new ASXMLList();
                return BindStatus.SUCCESS;
            }

            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchDescByGenName(genName, ref list);

            result = new ASXMLList(list.getUnderlyingArray(), list.length, noCopy: true);
            return (list.length == 0) ? BindStatus.SOFT_SUCCESS : BindStatus.SUCCESS;
        }

        /// <inheritdoc/>
        public override int AS_nextIndex(int index) => (index == 0) ? 1 : 0;

        /// <inheritdoc/>
        public override ASAny AS_nameAtIndex(int index) => (index == 1) ? (ASAny)index : default(ASAny);

        /// <inheritdoc/>
        public override ASAny AS_valueAtIndex(int index) => (index == 1) ? this : default(ASAny);

        #endregion

        /// <summary>
        /// Creates a new attribute or child node and adds it to the current node. A child node
        /// created by this method is added at the end of this node's child list.
        /// </summary>
        ///
        /// <param name="nodeType">The type of child node to create.</param>
        /// <param name="nodeName">The name of the node. For text and comment nodes, the name need not
        /// be specified and is ignored. A name is required for all other node types.</param>
        /// <param name="nodeText">The value to set for a text or attribute node. If
        /// <paramref name="nodeType"/> is <see cref="XMLNodeType.ELEMENT" qualifyHint="true"/>,
        /// this argument is ignored.</param>
        ///
        /// <returns>The created node. If <paramref name="nodeType"/> is
        /// <see cref="XMLNodeType.ATTRIBUTE" qualifyHint="true"/> and another attribute is defined
        /// on this element node with the name <paramref name="nodeName"/>, or <paramref name="nodeType"/>
        /// is <see cref="XMLNodeType.ELEMENT" qualifyHint="true"/>,
        /// <see cref="XMLNodeType.PROCESSING_INSTRUCTION" qualifyHint="true"/> or
        /// <see cref="XMLNodeType.ATTRIBUTE" qualifyHint="true"/>, and the local name of
        /// <paramref name="nodeName"/> is not a valid XML name, returns null.</returns>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item><description>TypeError #10201: This method is called on a non-element node.</description></item>
        /// </list>
        /// </exception>
        ///
        /// <remarks>
        /// <para>It is recommended to use this API for creating XML objects in .NET code. This is
        /// because this method creates the child node only once, while other methods that add
        /// children (such as <see cref="appendChild"/>) make a copy of the node before adding
        /// it.</para>
        /// </remarks>
        public virtual ASXML createChildNode(XMLNodeType nodeType, ASQName nodeName = null, string nodeText = null) =>
            throw ErrorHelper.createError(ErrorCode.MARIANA__XML_CREATE_CHILD_NON_ELEMENT);

        /// <summary>
        /// Gets the type of the this XML node.
        /// </summary>
        /// <seealso cref="nodeKind()" />
        public XMLNodeType nodeType => m_nodeType;

        /// <summary>
        /// Gets or sets the value of a text, attribute, comment or processing instruction node.
        /// </summary>
        /// <value>The value of a text, attribute, comment or processing instruction node, If
        /// this is an element node, the value of this property is always null and assigning to
        /// it will throw an exception.</value>
        public virtual string nodeText {
            get => null;
            set => throw ErrorHelper.createError(ErrorCode.MARIANA__XML_NODETEXT_ASSIGN_ELEMENT);
        }

        /// <summary>
        /// Returns true if this node is an element node.
        /// </summary>
        public bool isElement => m_nodeType == XMLNodeType.ELEMENT;

        /// <summary>
        /// Returns true if this node is an attribute node.
        /// </summary>
        public bool isAttribute => m_nodeType == XMLNodeType.ATTRIBUTE;

        /// <summary>
        /// Returns true if this node is a text node (but not a CDATA node).
        /// </summary>
        public bool isText => m_nodeType == XMLNodeType.ATTRIBUTE;

        /// <summary>
        /// Returns true if this node is a text or CDATA node.
        /// </summary>
        public bool isTextOrCDATA => m_nodeType == XMLNodeType.TEXT || m_nodeType == XMLNodeType.CDATA;

        /// <summary>
        /// Gets the child node of this node at the given index.
        /// </summary>
        /// <returns>The child at the index <paramref name="index"/>. If <paramref name="index"/> is -1,
        /// the last child is returned. If <paramref name="index"/> is a negative value other than -1
        /// or is greater than or equal to the number of children in this node, or this node is not
        /// an element node, null is returned.</returns>
        /// <param name="index">The child index.</param>
        ///
        /// <remarks>
        /// For performance reasons, this method should not be used to iterate over
        /// the node's children in a loop, as this method itself involves an iteration
        /// of the node's children to find the child at the given index. For iterating
        /// the node's children, use <see cref="getChildEnumerator"/>.
        /// </remarks>
        public ASXML getChildAtIndex(int index) {
            if (index < -1)
                return null;
            if (index == -1)
                return internalGetLastChild();

            for (ASXML cur = internalGetFirstChild(); cur != null; cur = cur.m_next, index--) {
                if (index == 0)
                    return cur;
            }

            return null;
        }

        /// <summary>
        /// Returns an <see cref="Enumerator"/> instance that can be used to enumerate this
        /// node's attributes.
        /// </summary>
        /// <returns>An <see cref="Enumerator"/> instance.</returns>
        /// <remarks>
        /// The returned <see cref="Enumerator"/> implements the <see cref="IEnumerable{ASXML}"/>
        /// and <see cref="IEnumerator{ASXML}"/> interfaces and can be used to iterate over the
        /// node's attributes, e.g. using a C# for-each loop.
        /// </remarks>
        public Enumerator getAttributeEnumerator() => new Enumerator(internalGetFirstAttr());

        /// <summary>
        /// Returns an <see cref="Enumerator"/> instance that can be used to enumerate this
        /// node's children.
        /// </summary>
        /// <returns>An <see cref="Enumerator"/> instance.</returns>
        /// <remarks>
        /// The returned <see cref="Enumerator"/> implements the <see cref="IEnumerable{ASXML}"/>
        /// and <see cref="IEnumerator{ASXML}"/> interfaces and can be used to iterate over the
        /// node's children, e.g. using a C# for-each loop.
        /// </remarks>
        public Enumerator getChildEnumerator() => new Enumerator(internalGetFirstChild());

        /// <summary>
        /// Returns a <see cref="DescendantEnumerator"/> instance that can be used to enumerate this
        /// node's descendants.
        /// </summary>
        /// <param name="includeThis">If this is true, iteration begins at this node; otherwise,
        /// iteration begins at this node's first child.</param>
        /// <returns>A <see cref="DescendantEnumerator"/> instance.</returns>
        /// <remarks>
        /// The returned <see cref="DescendantEnumerator"/> implements the <see cref="IEnumerable{ASXML}"/>
        /// and <see cref="IEnumerator{ASXML}"/> interfaces and can be used to iterate over the
        /// node's descendants, e.g. using a C# for-each loop. The iterator performs a depth-first
        /// traversal of the XML tree rooted at this node. If <paramref name="includeThis"/> is false
        /// (the default), the root node is excluded from the iteration.
        /// </remarks>
        public DescendantEnumerator getDescendantEnumerator(bool includeThis = false)
            => new DescendantEnumerator(this, includeThis);

        /// <summary>
        /// Adds a namespace declaration to the list of namespace prefix declarations for this node.
        /// </summary>
        /// <param name="ns">The namespace to add to the list of prefix declarations. This must be a
        /// Namespace or QName object. If this is a QName, the namespace of that QName is used. The
        /// namespace must have a non-null prefix.</param>
        /// <returns>This method always returns the instance on which it is called.</returns>
        ///
        /// <remarks>
        /// <para>If <paramref name="ns"/> does not have a non-null prefix, or this node is not an
        /// element, this method does nothing.</para>
        /// <para>If this node contains a namespace declaration with the same prefix as that of
        /// <paramref name="ns"/>, the existing declaration is replaced with the new one.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASXML addNamespace(ASAny ns) => this;

        /// <summary>
        /// Adds a new child node at the end of this XML node's child list.
        /// </summary>
        /// <param name="value">The child node to append.</param>
        /// <returns>This method always returns the instance on which it is called.</returns>
        ///
        /// <remarks>
        /// <para>If this node is not an element, this method does nothing.</para>
        /// <para>If <paramref name="value"/> is an XMLList object, all the nodes in that XMLList
        /// will be deep-copied and appended to the child list of this node, in order.</para>
        /// <para>If <paramref name="value"/> is an XML object, it will be deep-copied and the copy
        /// will be appended to the child list of this node.</para>
        /// <para>
        /// If <paramref name="value"/> is an XML object representing an attribute node, a text node
        /// is created whose value is the attribute value and that text node will be appended to the
        /// child list of this node. If <paramref name="value"/> is an XMLList, any attribute nodes
        /// in it are converted to text nodes in this way.
        /// </para>
        /// <para>If <paramref name="value"/> is not an XML or XMLList object, a new text node will
        /// be created whose value is <paramref name="value"/> converted to a string, and that node
        /// will be appended to the child list of this node.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXML appendChild(ASAny value) {
            if (!isElement)
                return this;

            string text = XMLHelper.tryGetStringFromObjectOrNode(value);
            ASXML lastChild = internalGetLastChild();

            if (text != null)
                internalInsertChildAfter(lastChild, new _TextNode(null, null, XMLNodeType.TEXT, text), mustCopy: false);
            else if (value.value is ASXMLList xmlList)
                internalInsertChildrenAfter(lastChild, xmlList, mustCopy: true);
            else
                internalInsertChildAfter(lastChild, (ASXML)value, mustCopy: true);

            return this;
        }

        /// <summary>
        /// Returns an XMLList containing all the attributes of this node that match the given name.
        /// </summary>
        /// <param name="name">A QName or a string.</param>
        /// <returns>An XMLList containing all the attributes of this node that match the name
        /// <paramref name="name"/>.</returns>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item><description>TypeError #1010: <paramref name="name"/> is null or undefined.</description></item>
        /// </list>
        /// </exception>
        ///
        /// <remarks>
        /// <para>If <paramref name="name"/> is a QName, all attributes matching that name will be
        /// included in the returned list.</para>
        /// <para>If <paramref name="name"/> is the string "*", all attributes of this node will be
        /// included in the returned list.</para>
        /// <para>If <paramref name="name"/> is not a QName or the string "*", all attributes
        /// matching a QName whose namespace is the public namespace, and whose local name is
        /// <paramref name="name"/> coerced to a string, will be included in the returned
        /// list.</para>
        /// <para><paramref name="name"/> (or its local name if it is a QName) must not have the "@"
        /// prefix before the attribute name.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList attribute(ASAny name) {
            if (name.value == null)
                throw ErrorHelper.createError(ErrorCode.UNDEFINED_REFERENCE_ERROR);

            var genName = XMLGenName.fromObjectAttrName(name);
            var attrList = new DynamicArray<ASXML>((genName.uri == null && genName.localName == null) ? 0 : 1);

            internalFetchNodesByGenName(genName, ref attrList);
            return new ASXMLList(attrList.getUnderlyingArray(), attrList.length, true, this, genName);
        }

        /// <summary>
        /// Returns an XMLList containing all the attributes of this node.
        /// </summary>
        /// <returns>An XMLList containing all the attributes of this node.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList attributes() {
            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchNodesByType(XMLNodeType.ATTRIBUTE, ref list);
            return new ASXMLList(list.getUnderlyingArray(), list.length, true, this, true);
        }

        /// <summary>
        /// Returns an XMLList containing the child nodes of this node that match the given name.
        /// </summary>
        /// <param name="name">A string, QName or integer index.</param>
        /// <returns>An XMLList containing all the child nodes of this node that match the given name,
        /// or the child node at the given index.</returns>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item><description>TypeError #1010: <paramref name="name"/> is null or undefined.</description></item>
        /// </list>
        /// </exception>
        ///
        /// <remarks>
        /// <para>If <paramref name="name"/> represents an attribute name (a string beginning with
        /// "@", or a QName whose local name begins with "@"), all attributes of the current node
        /// matching that name will be included in the returned list.</para>
        /// <para>If <paramref name="name"/> is an integer or a numeric string, an XMLList
        /// containing a single node which is the child node at the given index (or an empty list, if
        /// the index is out of bounds), is returned.</para>
        /// <para>If <paramref name="name"/> is a QName, the child elements matching that name will
        /// be included in the returned list.</para>
        /// <para>If <paramref name="name"/> is the string "*", all children of this node will be
        /// included in the returned list.</para>
        /// <para>If <paramref name="name"/> is not an integer, a numeric string, a QName or the
        /// string "*", the child elements matching a QName whose namespace is the default XML
        /// namespace and local name is <paramref name="name"/> coerced to a string, will be
        /// included in the returned list.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList child(ASAny name) {
            if (name.value == null)
                throw ErrorHelper.createError(ErrorCode.UNDEFINED_REFERENCE_ERROR);

            var genName = XMLGenName.fromObject(name, 0);

            if (genName.isIndex) {
                ASXML[] indexed = Array.Empty<ASXML>();
                if (!genName.isAttr) {
                    ASXML childAtIndex = getChildAtIndex(genName.index);
                    if (childAtIndex != null)
                        indexed = new ASXML[] {childAtIndex};
                }
                return new ASXMLList(indexed, indexed.Length, noCopy: true);
            }

            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchNodesByGenName(genName, ref list);
            return new ASXMLList(list.getUnderlyingArray(), list.length, true, this, genName);
        }

        /// <summary>
        /// Returns an XMLList containing all the children of this node.
        /// </summary>
        /// <returns>An XMLList containing all the children of this node.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList children() {
            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchNodesByGenName(XMLGenName.anyChild(), ref list);
            return new ASXMLList(list.getUnderlyingArray(), list.length, true, this);
        }

        /// <summary>
        /// Returns an XMLList containing all the children of this node that are comments.
        /// </summary>
        /// <returns>An XMLList containing all the children of this node that are comments.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList comments() {
            DynamicArray<ASXML> commentsList = new DynamicArray<ASXML>();
            internalFetchNodesByType(XMLNodeType.COMMENT, ref commentsList);
            return new ASXMLList(commentsList.getUnderlyingArray(), commentsList.length, true, this);
        }

        /// <summary>
        /// Returns a value indicating whether this node is equal to <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to compare this node to.</param>
        /// <returns>True if this node is equal to <paramref name="value"/> by the definition of the
        /// weak equality operator, otherwise false.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public bool contains(ASAny value) => ASAny.AS_weakEq(this, value);

        /// <summary>
        /// Gets the zero-based index of the current node with respect to its parent.
        /// </summary>
        /// <returns>The zero-based index of the current node in the child list of its parent. If the
        /// node does not have a parent, or is an attribute node, this method returns -1.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public int childIndex() {
            if (m_parent == null || isAttribute)
                return -1;

            int index = 0;
            for (ASXML cur = m_parent.internalGetFirstChild(); cur != null; cur = cur.m_next, index++) {
                if (cur == this)
                    return index;
            }

            return -1;
        }

        /// <summary>
        /// Returns a deep copy of this XML node, including its attributes and children.
        /// </summary>
        /// <returns>A deep copy of the XML node.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASXML copy() => null;

        /// <summary>
        /// Returns an XMLList containing all the nodes matching the given name, which are descendants
        /// (children, grandchildren and so on) of this node.
        /// </summary>
        /// <param name="name">A QName or string.</param>
        /// <returns>An XMLList containing all the nodes matching the given name, which are
        /// descendants of this node.</returns>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item><description>TypeError #1010: <paramref name="name"/> is null or undefined.</description></item>
        /// </list>
        /// </exception>
        ///
        /// <remarks>
        /// <para>If <paramref name="name"/> represents an attribute name (a string beginning with
        /// "@", or a QName whose local name begins with "@"), all attributes of the current node
        /// matching that name are included in the returned list.</para>
        /// <para>If <paramref name="name"/> is a QName, the descendant elements matching that name
        /// will be included in the returned list.</para>
        /// <para>If <paramref name="name"/> is the string "*", all descendants of this node will be
        /// included in the returned list.</para>
        /// <para>If <paramref name="name"/> is not a QName or the string "*", and is not an
        /// attribute name, the descendant elements matching a QName whose namespace is the default
        /// XML namespace and local name is <paramref name="name"/> coerced to a string, will be
        /// included in the returned list.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList descendants([ParamDefaultValue("*")] ASAny name) {
            if (name.value == null)
                throw ErrorHelper.createError(ErrorCode.UNDEFINED_REFERENCE_ERROR);

            var genName = XMLGenName.fromObject(name, 0);

            if (genName.isIndex)
                return new ASXMLList();

            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchDescByGenName(genName, ref list);
            return new ASXMLList(list.getUnderlyingArray(), list.length, true);
        }

        /// <summary>
        /// Returns an XMLList containing all the child element(s) of this node that match the given
        /// name.
        /// </summary>
        /// <param name="name">A string or QName.</param>
        /// <returns>An XMLList containing all the child element(s) of this node that match the name
        /// <paramref name="name"/>.</returns>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item><description>TypeError #1010: <paramref name="name"/> is null or undefined.</description></item>
        /// </list>
        /// </exception>
        ///
        /// <remarks>
        /// <para>If <paramref name="name"/> is an integer, a numeric string, or a string or QName
        /// representing an attribute name (having the "@" prefix), an empty list is returned.</para>
        /// <para>If <paramref name="name"/> is a QName, the child elements matching that name will
        /// be included in the returned list.</para>
        /// <para>If <paramref name="name"/> is the string "*", all child nodes of this node that
        /// are elements will be included in the returned list.</para>
        /// <para>If <paramref name="name"/> is not a QName or the string "*", the child elements
        /// matching a QName whose namespace is the default XML namespace and local name is
        /// <paramref name="name"/> coerced to a string, will be included in the returned
        /// list.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList elements([ParamDefaultValue("*")] ASAny name) {
            if (name.value == null)
                throw ErrorHelper.createError(ErrorCode.UNDEFINED_REFERENCE_ERROR);

            var genName = XMLGenName.fromObject(name, 0);

            if (genName.isIndex || genName.isAttr)
                return new ASXMLList(Array.Empty<ASXML>(), 0, true, this);

            DynamicArray<ASXML> list = new DynamicArray<ASXML>();

            if (genName.uri == null && genName.localName == null)
                internalFetchNodesByType(XMLNodeType.ELEMENT, ref list);
            else
                internalFetchNodesByGenName(genName, ref list);

            return new ASXMLList(list.getUnderlyingArray(), list.length, true, this, genName);
        }

        /// <summary>
        /// Gets a value indicating whether this XML object represents a complex content node.
        /// </summary>
        /// <returns>True if this XML object represents a complex content node, otherwise
        /// false.</returns>
        ///
        /// <remarks>
        /// A complex content node is one which is an element node having at least one child element.
        /// Note that if a node is not a complex content node, it is not always true that it is a
        /// simple content node. (Comments and processing instructions are neither simple content nor
        /// complex content nodes.)
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public bool hasComplexContent() {
            if (!isElement)
                return false;

            for (ASXML cur = internalGetFirstChild(); cur != null; cur = cur.m_next) {
                if (cur.isElement)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Gets a value indicating whether this XML object represents a simple content node.
        /// </summary>
        /// <returns>True if this XML object represents a simple content node, otherwise
        /// false.</returns>
        ///
        /// <remarks>
        /// A simple content node is one which is a text node, an attribute, or an element node that
        /// does not have any child nodes that are elements. Note that if a node is not a simple
        /// content node, it is not always true that it is a complex content node. (Comments and
        /// processing instructions are neither simple content nor complex content nodes.)
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public bool hasSimpleContent() {
            if (isElement) {
                for (ASXML child = internalGetFirstChild(); child != null; child = child.m_next) {
                    if (child.isElement)
                        return false;
                }
                return true;
            }

            const int mask = (1 << (int)XMLNodeType.TEXT) | (1 << (int)XMLNodeType.CDATA) | (1 << (int)XMLNodeType.ATTRIBUTE);
            return ((1 << (int)m_nodeType) & mask) != 0;
        }

        /// <summary>
        /// Returns an Array containing all the namespace declarations available to the current node.
        /// </summary>
        /// <returns>An Array containing <see cref="ASNamespace"/> objects representing all the
        /// namespace declarations available to this node.</returns>
        ///
        /// <remarks>
        /// The array returned by this method will include all the namespaces declared by this node
        /// (if it is an element) and namespaces declared by the node's ancestors that are not hidden
        /// by declarations of this node.
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASArray inScopeNamespaces() {
            return (m_parent == null) ? new ASArray() : m_parent.inScopeNamespaces();
        }

        /// <summary>
        /// Adds a new child node into this XML node's child list after another child node.
        /// </summary>
        ///
        /// <param name="child1">A child node of this node after which to insert
        /// <paramref name="child2"/>. If this is null, the child node is inserted at the beginning
        /// of the child list of this node.</param>
        /// <param name="child2">The child to insert into this node's child list after
        /// <paramref name="child1"/>.</param>
        ///
        /// <returns>
        /// If this node is not an element node, or <paramref name="child1"/> is not null or an XML
        /// object, is an XML instance representing an attribute, or an XML instance representing a
        /// node that is not a child of this node, returns undefined. Otherwise, returns this instance
        /// (on which the method is called).
        /// </returns>
        ///
        /// <remarks>
        /// <para>If this node is not an element, or <paramref name="child1"/> is not null or an XML
        /// object, or is an XML object representing an attribute or a node that is not a child of
        /// this node, this method does nothing.</para>
        /// <para>If <paramref name="child2"/> is an XMLList object, all the nodes in that XMLList
        /// will be deep-copied and inserted into the child list of this node after
        /// <paramref name="child1"/>, in order.</para>
        /// <para>If <paramref name="child2"/> is an XML object, it will be deep-copied and the copy
        /// will be inserted into the child list after <paramref name="child1"/>.</para>
        /// <para>
        /// If <paramref name="child2"/> is an XML object representing an attribute node, a text
        /// node is created whose value is equal to the attribute value and that text node will be
        /// inserted into the child list. If <paramref name="child2"/> is an XMLList, any attribute
        /// nodes in it are converted to text nodes in this way.
        /// </para>
        /// <para>If <paramref name="child2"/> is not an XML or XMLList object, a new text node will
        /// be created whose value is <paramref name="child2"/> converted to a string, and that node
        /// will be inserted into the child list.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASAny insertChildAfter(ASAny child1, ASAny child2) {
            if (!isElement)
                return ASAny.undefined;

            string text = XMLHelper.tryGetStringFromObjectOrNode(child2);
            ASXML insertLocation = _checkChildOfCurrentNode(child1);

            if (text != null)
                internalInsertChildAfter(insertLocation, new _TextNode(null, null, XMLNodeType.TEXT, text), mustCopy: false);
            else if (child2.value is ASXMLList xmlList)
                internalInsertChildrenAfter(insertLocation, xmlList, mustCopy: true);
            else
                internalInsertChildAfter(insertLocation, (ASXML)child2, mustCopy: true);

            return this;
        }

        /// <summary>
        /// Adds a new child node into this XML node's child list before another child node.
        /// </summary>
        ///
        /// <param name="child1">A child node of this node before which to insert
        /// <paramref name="child2"/>. If this is null, the child node is inserted at the end of the
        /// child list of this node.</param>
        /// <param name="child2">The child to insert into this node's child list before
        /// <paramref name="child1"/>.</param>
        ///
        /// <returns>
        /// If this node is not an element node, or <paramref name="child1"/> is not null or an XML
        /// object, is an XML instance representing an attribute, or an XML instance representing a
        /// node that is not a child of this node, returns undefined. Otherwise, returns this instance
        /// (on which the method is called).
        /// </returns>
        ///
        /// <remarks>
        /// <para>If this node is not an element, or <paramref name="child1"/> is not null or an XML
        /// object, or is an XML object representing an attribute or a node that is not a child of
        /// this node, this method does nothing.</para>
        /// <para>If <paramref name="child2"/> is an XMLList object, all the nodes in that XMLList
        /// will be deep-copied and inserted into the child list of this node before
        /// <paramref name="child1"/>, in order.</para>
        /// <para>If <paramref name="child2"/> is an XML object, it will be deep-copied and the copy
        /// will be inserted into the child list before <paramref name="child1"/>.</para>
        /// <para>
        /// If <paramref name="child2"/> is an XML object representing an attribute node, a text
        /// node is created whose value is equal to the attribute value and that text node will be
        /// inserted into the child list. If <paramref name="child2"/> is an XMLList, any attribute
        /// nodes in it are converted to text nodes in this way.
        /// </para>
        /// <para>If <paramref name="child2"/> is not an XML or XMLList object, a new text node will
        /// be created whose value is <paramref name="child2"/> converted to a string, and that node
        /// will be inserted into the child list.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASAny insertChildBefore(ASAny child1, ASAny child2) {
            if (!isElement)
                return ASAny.undefined;

            string text = XMLHelper.tryGetStringFromObjectOrNode(child2);

            ASXML insertLocation = _checkChildOfCurrentNode(child1);

            if (insertLocation == null && !child1.isNull)
                return ASAny.undefined;

            if (insertLocation == null) {
                insertLocation = internalGetLastChild();
            }
            else {
                // Get the previous node.
                ASXML cur = internalGetFirstChild();

                if (cur == insertLocation) {
                    insertLocation = null;
                }
                else {
                    for (; cur != null; cur = cur.m_next) {
                        if (cur.m_next == insertLocation) {
                            insertLocation = cur;
                            break;
                        }
                    }
                }
            }

            if (text != null)
                internalInsertChildAfter(insertLocation, new _TextNode(null, null, XMLNodeType.TEXT, text), mustCopy: false);
            else if (child2.value is ASXMLList xmlList)
                internalInsertChildrenAfter(insertLocation, xmlList, mustCopy: true);
            else
                internalInsertChildAfter(insertLocation, (ASXML)child2, mustCopy: true);

            return this;
        }

        /// <summary>
        /// This method always returns the value 1.
        /// </summary>
        /// <returns>This method always returns the value 1.</returns>
        /// <remarks>
        /// This method exists to allow XML objects to be used where an XMLList is expected. (The XML
        /// object effectively acts as a single-element XMLList)
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public int length() => 1;

        /// <summary>
        /// Gets the local name of this node.
        /// </summary>
        /// <returns>The local name of this node.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public string localName() => m_name.localName;

        /// <summary>
        /// Gets the qualified name of this node.
        /// </summary>
        /// <returns>The qualified name of this node.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASQName name() {
            ASQName name = m_name;

            if (name == null || name.prefix != null)
                return name;

            string prefix = internalFindPrefixForName(name, isAttribute);
            if (prefix == null)
                return name;

            name = ASQName.unsafeCreate(prefix, name.uri, name.localName);

            System.Threading.Thread.MemoryBarrier();
            m_name = name;
            return name;
        }

        /// <summary>
        /// Gets the namespace of this node's name, or a namespace declaration with the given prefix.
        /// </summary>
        /// <param name="prefix">If specified, returns the namespace associated with the given prefix,
        /// otherwise returns the namespace of the node's name.</param>
        ///
        /// <returns>
        /// Returns the namespace declared with the given prefix on the node or any of its ancestors,
        /// if <paramref name="prefix"/> is not null; otherwise, returns the namespace of the node's
        /// name, or null if this node is not an element or attribute node. If
        /// <paramref name="prefix"/> is not null and no namespace declaration with that prefix was
        /// found, returns undefined.
        /// </returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASAny @namespace(OptionalParam<ASAny> prefix = default) {
            if (prefix.isSpecified)
                return m_parent.@namespace(prefix);

            return (m_nodeType != XMLNodeType.ELEMENT && m_nodeType != XMLNodeType.ATTRIBUTE)
                ? ASAny.@null
                : name().getNamespace();
        }

        /// <summary>
        /// Gets an array containing all the namespaces declared by this node.
        /// </summary>
        /// <returns>An array containing all the namespace declarations of this node.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASArray namespaceDeclarations() => new ASArray();

        /// <summary>
        /// Gets a string representing the type of this node.
        /// </summary>
        /// <returns>A string representing the type of this node. This is be one of the following:
        /// "element", "attribute", "text", "comment" or "processing-instruction". (CDATA nodes will
        /// return "text")</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public string nodeKind() {
            switch (m_nodeType) {
                case XMLNodeType.ATTRIBUTE:
                    return "attribute";
                case XMLNodeType.COMMENT:
                    return "comment";
                case XMLNodeType.ELEMENT:
                    return "element";
                case XMLNodeType.PROCESSING_INSTRUCTION:
                    return "processing-instruction";
                case XMLNodeType.TEXT:
                case XMLNodeType.CDATA:
                    return "text";
                default:
                    return null;
            }
        }

        /// <summary>
        /// Normalises the child nodes of this node and all its descendants by removing empty text
        /// nodes and merging adjacent text nodes.
        /// </summary>
        /// <returns>This method always returns the instance on which it is called.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASXML normalize() => this;

        /// <summary>
        /// Gets the parent node of this node.
        /// </summary>
        /// <returns>The parent node of this node. If the node has no parent, returns null.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXML parent() => m_parent;

        /// <summary>
        /// Adds a new child node at the beginning of this XML node's child list.
        /// </summary>
        /// <param name="value">The child node to append.</param>
        /// <returns>This method always returns the instance on which it is called.</returns>
        ///
        /// <remarks>
        /// <para>If this node is not an element, this method does nothing.</para>
        /// <para>If <paramref name="value"/> is an XMLList object, all the nodes in that XMLList
        /// will be deep-copied and prepended to the child list of this node, in order.</para>
        /// <para>If <paramref name="value"/> is an XML object, it will be deep-copied and the copy
        /// will be prepended to the child list of this node.</para>
        /// <para>If <paramref name="value"/> is not an XML or XMLList object, a new text node will
        /// be created whose value is <paramref name="value"/> converted to a string, and that node
        /// will be prepended to the child list of this node.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXML prependChild(ASAny value) {
            if (!isElement)
                return this;

            string text = XMLHelper.tryGetStringFromObjectOrNode(value);

            if (text != null)
                internalInsertChildAfter(null, new _TextNode(null, null, XMLNodeType.TEXT, text), mustCopy: false);
            else if (value.value is ASXMLList xmlList)
                internalInsertChildrenAfter(null, xmlList, mustCopy: true);
            else
                internalInsertChildAfter(null, (ASXML)value, mustCopy: true);

            return this;
        }

        /// <summary>
        /// Returns an XMLList containing all the children of this node that are processing
        /// instructions with the given name.
        /// </summary>
        /// <param name="name">A string or QName.</param>
        /// <returns>An XMLList containing all the children of this node that are processing
        /// instructions with the given name.</returns>
        ///
        /// <exception cref="AVM2Exception">
        /// <list type="bullet">
        /// <item><description>TypeError #1010: <paramref name="name"/> is null or undefined.</description></item>
        /// </list>
        /// </exception>
        ///
        /// <remarks>
        /// <para>
        /// If <paramref name="name"/> is a QName whose namespace URI is null or the empty string,
        /// all processing instructions having the same local name as that of the QName are included
        /// in the returned list. If the namespace URI of the QName is neither null nor the empty
        /// string, an empty XMLList is returned.
        /// </para>
        /// <para>If <paramref name="name"/> is the string "*", all child nodes of this node that
        /// are processing instructions are included in the returned list.</para>
        /// <para>If <paramref name="name"/> is not a QName or the string "*", all processing
        /// instructions whose local name is equal to the result of coercing <paramref name="name"/>
        /// to a string are included in the returned list.</para>
        /// <para>This is the only method that can be used to obtain processing instruction nodes
        /// having a particular name. Methods such as <see cref="child"/> and
        /// <see cref="descendants"/> ignore processing instructions except when the name is the
        /// "any" name.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList processingInstructions([ParamDefaultValue("*")] ASAny name) {
            if (name.value == null)
                throw ErrorHelper.createError(ErrorCode.UNDEFINED_REFERENCE_ERROR);

            var genName = XMLGenName.fromObjectProcInstrName(name);
            DynamicArray<ASXML> piList = new DynamicArray<ASXML>();
            internalFetchNodesByGenName(genName, ref piList);
            return new ASXMLList(piList.getUnderlyingArray(), piList.length, true, this);
        }

        /// <summary>
        /// Removes the given namespace from the namespace declaration list of this node, removing any
        /// prefix associated with it from this node and all its descendants.
        /// </summary>
        /// <param name="ns">The namespace to remove from the namespace declarations of this node. If
        /// this is a QName, the namespace of that QName will be used. If this is not a Namespace or
        /// QName object, it will be converted to a string and used as the namespace URI.</param>
        /// <returns>This method always returns the instance on which it is called.</returns>
        ///
        /// <remarks>
        /// <para>
        /// If <paramref name="ns"/> is a namespace with a prefix, only the namespace declaration
        /// having both a matching prefix and URI will be removed; if <paramref name="ns"/> is a
        /// namespace without a prefix (or a string), a declaration with a matching URI will be
        /// removed. In such a case, if there is more than one declaration with a matching URI and
        /// different prefixes, any one of them will be removed (which one is undefined).
        /// </para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASXML removeNamespace(ASAny ns) => this;

        /// <summary>
        /// Replaces any child nodes having a given name or the child node at a given index with a new
        /// node.
        /// </summary>
        /// <param name="name">A string, QName or numeric index.</param>
        /// <param name="newValue">The replacement value.</param>
        /// <returns>This method always returns the instance on which it is called.</returns>
        ///
        /// <remarks>
        /// <para>If this node is not an element, this method does nothing.</para>
        /// <para>
        /// If <paramref name="name"/> is a numeric index (an integer or a numeric string), the
        /// child at that index is replaced with <paramref name="newValue"/>. If the index is
        /// greater than or equal to the number of children in this node, the new node is appended to
        /// this node's child list, as if by calling
        /// <c>appendChild(<paramref name="newValue"/>)</c>.
        /// </para>
        /// <para>
        /// If <paramref name="name"/> is a QName, all child elements whose names match that
        /// qualified name will be deleted. If <paramref name="name"/> is not a numeric index or
        /// QName, all child elements whose names match a qualified name whose namespace is the
        /// current default XML namespace and whose local name is <paramref name="name"/> coerced to
        /// a string, will be deleted.
        /// </para>
        /// <para>If <paramref name="newValue"/> is an XMLList object, all the nodes in that XMLList
        /// will be deep-copied and inserted into the child list of this node, in order.</para>
        /// <para>If <paramref name="newValue"/> is an XML object, it will be deep-copied and the
        /// copy will be inserted into the child list of this node.</para>
        /// <para>If <paramref name="newValue"/> is not an XML or XMLList object, a new text node
        /// will be created whose value is <paramref name="newValue"/> converted to a string, and
        /// that node will be inserted into the child list of this node.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public virtual ASXML replace(ASAny name, ASAny newValue) => this;

        /// <summary>
        /// Replaces all existing children of this node with one or more new children.
        /// </summary>
        /// <param name="value">The node to be set as the new child of this node.</param>
        /// <returns>This method always returns the instance on which it is called.</returns>
        ///
        /// <remarks>
        /// If <paramref name="value"/> is an XML or XMLList, the node(s) are deep copied before
        /// they are inserted into the child list of this node. If this node is not an element,
        /// this method does nothing.
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXML setChildren(ASAny value) {
            if (!isElement)
                return this;

            string text = XMLHelper.tryGetStringFromObjectOrNode(value);

            internalClearChildren();

            if (text != null) {
                if (text.Length != 0)
                    internalInsertChildAfter(null, new _TextNode(null, null, XMLNodeType.TEXT, text), mustCopy: false);
            }
            else if (value.value is ASXMLList xmlList) {
                internalInsertChildrenAfter(null, xmlList, mustCopy: true);
            }
            else {
                internalInsertChildAfter(null, (ASXML)value, mustCopy: true);
            }

            return this;
        }

        /// <summary>
        /// Changes the local name of this node to the given name.
        /// </summary>
        /// <param name="name">A string or QName.</param>
        ///
        /// <remarks>
        /// <para>If <paramref name="name"/> is a QName, this node's local name will be set to the
        /// local name of that QName. Otherwise, the local name will be set to the result of coercing
        /// <paramref name="name"/> to a string.</para>
        /// <para>If this node is a text or comment node, this method does nothing.</para>
        /// <para>If the new local name is not a valid XML name, the name of this node will not be
        /// changed.</para>
        /// <para>If this node is an attribute and its parent element contains another attribute whose
        /// name would conflict if this attribute's local name is changed, or the local name is one
        /// that is reserved for namespace declaration attributes, the local name of this node will
        /// not be changed.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public void setLocalName(ASAny name) {
            if (isTextOrCDATA || m_nodeType == XMLNodeType.COMMENT)
                return;

            string newLocalName = (name.value is ASQName qname)
                ? ASString.AS_convertString(qname.localName)
                : ASAny.AS_convertString(name);

            if (!XMLHelper.isValidName(newLocalName))
                return;

            var newName = ASQName.unsafeCreate(m_name.prefix, m_name.uri, newLocalName);

            if (isAttribute && m_parent != null && !m_parent._checkAttributeName(newName, this))
                return;

            m_name = newName;
        }

        /// <summary>
        /// Changes the name of this node to the given name.
        /// </summary>
        /// <param name="name">A QName or string to be used as the new name of this node.</param>
        ///
        /// <remarks>
        /// <para>If <paramref name="name"/> is not a Namespace or QName, the name of this node will
        /// be set to a QName whose namespace is the default XML namespace and whose local name is
        /// <paramref name="name"/> coerced to a string.</para>
        /// <para>If <paramref name="name"/> is a QName whose namespace is the "any" namespace, the
        /// name of this node will be set to a QName whose namespace is the default XML namespace and
        /// whose local name is the local name of <paramref name="name"/>.</para>
        /// <para>If this node is a text or comment node, this method does nothing.</para>
        /// <para>If the new name has a local name that is not a valid XML name, the name of this node
        /// will not be changed.</para>
        /// <para>If this node is a processing instruction, only the local name of
        /// <paramref name="name"/> is used; the names of processing instructions are always in the
        /// public namespace.</para>
        /// <para>If this node is an attribute, and its parent element contains another attribute
        /// whose name would conflict if this attribute's name is changed, or the new name is a name
        /// that is reserved for namespace declaration attributes, the name of this node will not be
        /// changed.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public void setName(ASAny name) {
            if (isTextOrCDATA || m_nodeType == XMLNodeType.COMMENT)
                return;

            // isAttr determines whether the public namespace or the DXNS must be used
            // if the object is not a Namespace/QName. For the setName method, the DXNS
            // is always used even if this node is an attribute (unlike the property get/set
            // methods), so isAttr must be set to false.
            ASQName qname = XMLHelper.objectToQName(name, isAttr: false);

            bool isProcInstr = m_nodeType == XMLNodeType.PROCESSING_INSTRUCTION;

            if (isProcInstr)
                qname = new ASQName(ASNamespace.@public, qname.localName);
            else if (qname.uri == null)
                qname = new ASQName(ASNamespace.getDefault(), qname.localName);

            if (!XMLHelper.isValidName(qname.localName))
                return;

            if (m_nodeType != XMLNodeType.ATTRIBUTE) {
                m_name = qname;
                if (qname.prefix != null && qname.uri.Length != 0)
                    addNamespace(m_name.getNamespace());
                return;
            }

            if (qname.prefix != null
                && ((qname.prefix.Length == 0 && qname.uri.Length != 0) || qname.prefix == "xmlns"))
            {
                qname = new ASQName(qname.uri, qname.localName);
            }

            if (m_parent != null && !m_parent._checkAttributeName(qname, this))
                return;

            m_name = qname;
            if (m_parent != null && qname.prefix != null && qname.uri.Length != 0)
                m_parent.addNamespace(qname.getNamespace());
        }

        /// <summary>
        /// Changes the namespace of this node's name to the given namespace.
        /// </summary>
        /// <param name="ns">The namespace to set as this node's namespace. If this is a QName, the
        /// namespace of that QName will be used. If this is not a Namespace or QName object, it will
        /// be converted to a string and used as the namespace URI.</param>
        ///
        /// <remarks>
        /// <para>If this node is a text, comment or processing instruction node, or
        /// <paramref name="ns"/> is the "any" namespace, this method does nothing.</para>
        /// <para>If this node is an attribute, and its parent element contains another attribute
        /// whose name would conflict if this attribute's namespace is changed, the namespace of this
        /// node will not be changed.</para>
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public void setNamespace(ASAny ns) {
            if (isTextOrCDATA || m_nodeType == XMLNodeType.COMMENT || m_nodeType == XMLNodeType.PROCESSING_INSTRUCTION)
                return;

            ASNamespace nameSpace = XMLHelper.objectToNamespace(ns);

            if (m_nodeType != XMLNodeType.ATTRIBUTE) {
                m_name = new ASQName(nameSpace, m_name.localName);
                if (nameSpace.prefix != null && nameSpace.uri.Length != 0)
                    addNamespace(nameSpace);
                return;
            }

            ASQName newName;
            if (nameSpace.prefix != null
                && ((nameSpace.prefix.Length == 0 && nameSpace.uri.Length != 0) || nameSpace.prefix == "xmlns"))
            {
                newName = new ASQName(nameSpace.uri, m_name.localName);
            }
            else {
                newName = new ASQName(nameSpace, m_name.localName);
            }

            if (m_parent != null && !m_parent._checkAttributeName(newName, this))
                return;

            m_name = newName;
            if (m_parent != null && nameSpace.prefix != null && nameSpace.uri.Length != 0)
                m_parent.addNamespace(nameSpace);
        }

        /// <summary>
        /// Returns an XMLList containing all the children of this node that are text nodes.
        /// </summary>
        /// <returns>An XMLList containing all the children of this node that are text
        /// nodes.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public ASXMLList text() {
            DynamicArray<ASXML> list = new DynamicArray<ASXML>();
            internalFetchNodesByType(XMLNodeType.TEXT, ref list);
            return new ASXMLList(list.getUnderlyingArray(), list.length, true, this);
        }

        /// <summary>
        /// Converts the XML node to a string. If the node has simple content, the value of the child
        /// node in it is returned (if there is more than one child node, the values of all child
        /// nodes are concatenated). Otherwise, a formatted XML string is returned.
        /// </summary>
        ///
        /// <returns>The string representation of the XML object.</returns>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin", name = "toString")]
        [AVM2ExportPrototypeMethod(name = "toString")]
        public new string AS_toString() {
            if (hasSimpleContent())
                return internalSimpleToString();

            XMLWriter writer = new XMLWriter();
            return writer.makeString(this);
        }

        /// <summary>
        /// Converts the XML node to an XML formatted string.
        /// </summary>
        /// <returns>The string representation of the XML object.</returns>
        /// <remarks>
        /// Unlike the toString method, this will always use XML element syntax for element nodes even
        /// if they have simple content.
        /// </remarks>
        [AVM2ExportTrait(nsUri = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public string toXMLString() {
            if (isText)
                return escapeText(nodeText);

            if (m_nodeType == XMLNodeType.CDATA) {
                string text = nodeText;
                if (text.IndexOf("]]>", StringComparison.Ordinal) != -1) {
                    // If a CDATA node contains "]]>", it would be invalid XML when output as CDATA.
                    // So output it as an ordinary text node with proper escaping.
                    return escapeText(text);
                }
                return "<![CDATA[" + text + "]]>";
            }

            if (isAttribute)
                return escapeAttribute(nodeText);

            XMLWriter writer = new XMLWriter();
            return writer.makeString(this);
        }

        /// <summary>
        /// Returns the object that is used in place of the XML instance in JSON output. This method
        /// can be redefined at the prototype level.
        /// </summary>
        /// <param name="key">The name of the object property of which this object is the
        /// value.</param>
        /// <returns>The object that is used in place of the XML instance in JSON. For a XML object,
        /// the default method returns the string "XML".</returns>
        //[AVM2ExportTrait(nsName = "http://adobe.com/AS3/2006/builtin")]
        [AVM2ExportPrototypeMethod]
        public string toJSON(ASAny key) => "XML";

        /// <inheritdoc/>
        public override bool propertyIsEnumerable(ASAny name = default(ASAny)) => (string)name == "0";

        /// <summary>
        /// An XMLTextNode object represents an XML node that is not an element node. These nodes
        /// include attributes, processing instructions, comments, text nodes and CDATA nodes.
        /// </summary>
        private sealed class _TextNode : ASXML {
            private string m_text;

            internal _TextNode(ASQName name, ASXML parent, XMLNodeType nodeType, string text)
                : base(name, parent, nodeType)
            {
                nodeText = text;
            }

            public override ASXML copy() => new _TextNode(m_name, null, m_nodeType, nodeText);

            public override string nodeText {
                get => m_text;
                set => m_text = value ?? "";
            }
        }

        /// <summary>
        /// Represents an element node in E4X.
        /// </summary>
        private sealed class _ElementNode : ASXML {

            private ASXML m_firstAttr;
            private ASXML m_firstChild;
            private ASXML m_lastChild;
            private DynamicArray<ASNamespace> m_nsdecls;

            internal _ElementNode(ASQName name, ASXML parent) : base(name, parent, XMLNodeType.ELEMENT) { }

            internal _ElementNode(
                ASQName name,
                ASXML parent,
                ASXML firstAttr,
                ASXML firstChild,
                ASXML lastChild,
                ASNamespace[] nsdecls
            )
                : base(name, parent, XMLNodeType.ELEMENT)
            {
                m_firstAttr = firstAttr;
                m_firstChild = firstChild;
                m_lastChild = lastChild;

                nsdecls = nsdecls ?? Array.Empty<ASNamespace>();
                m_nsdecls = new DynamicArray<ASNamespace>(nsdecls, nsdecls.Length);
            }

            protected override ASXML internalGetFirstChild() => m_firstChild;
            protected override ASXML internalGetLastChild() => m_lastChild;
            protected override ASXML internalGetFirstAttr() => m_firstAttr;

            /// <summary>
            /// This method must be called before inserting a new child node into this element. It
            /// converts attributes to text nodes, creates a deep copy if <paramref name="mustCopy"/>
            /// is true, removes the node from its existing parent if it has one, and throws an exception
            /// if inserting would create a cycle.
            /// </summary>
            ///
            /// <param name="nodeToInsert">The node to be inserted.</param>
            /// <param name="mustCopy">Set to true if a deep copy of <paramref name="nodeToInsert"/> must be
            /// inserted as a child of this node, instead of <paramref name="nodeToInsert"/> itself.</param>
            ///
            /// <returns>The child node that must be inserted into the child list of this element. It
            /// may be <paramref name="nodeToInsert"/> itself or a copy of it, depending on the value
            /// of <paramref name="mustCopy"/> and the type of the node.</returns>
            private ASXML _copyOrCheckChildToBeInserted(ASXML nodeToInsert, bool mustCopy) {
                if (nodeToInsert.isAttribute) {
                    // Convert attributes to text nodes.
                    return new _TextNode(null, null, XMLNodeType.TEXT, nodeToInsert.nodeText);
                }

                if (mustCopy)
                    return nodeToInsert.copy();

                if (nodeToInsert.isElement) {
                    // Check if `nodeToInsert` is the same as, or an ancestor of, this node,
                    // in which case inserting would create a cycle.
                    for (var curNode = this; curNode != null; curNode = curNode.m_parent) {
                        if (curNode == nodeToInsert)
                            throw ErrorHelper.createError(ErrorCode.XML_CYCLIC_LOOP);
                    }
                }

                if (nodeToInsert.m_parent != null)
                    nodeToInsert.m_parent.internalDeleteChildOrAttr(nodeToInsert);

                return nodeToInsert;
            }

            internal override ASXML internalInsertChildAfter(ASXML prevNode, ASXML nodeToInsert, bool mustCopy) {
                if (prevNode == nodeToInsert && !mustCopy)
                    return nodeToInsert;

                nodeToInsert = _copyOrCheckChildToBeInserted(nodeToInsert, mustCopy);
                nodeToInsert.m_parent = this;

                if (prevNode == null) {
                    nodeToInsert.m_next = m_firstChild;
                    m_firstChild = nodeToInsert;
                }
                else {
                    nodeToInsert.m_next = prevNode.m_next;
                    prevNode.m_next = nodeToInsert;
                }

                if (nodeToInsert.m_next == null)
                    m_lastChild = nodeToInsert;

                return nodeToInsert;
            }

            internal override void internalInsertChildrenAfter(ASXML prevNode, ASXMLList nodesToInsert, bool mustCopy) =>
                internalInsertChildrenAfter(prevNode, nodesToInsert.getItems().asSpan(), mustCopy);

            internal void internalInsertChildrenAfter(ASXML prevNode, ReadOnlySpan<ASXML> nodesToInsert, bool mustCopy) {
                for (int i = 0; i < nodesToInsert.Length; i++) {
                    ASXML insertedNode = internalInsertChildAfter(prevNode, nodesToInsert[i], mustCopy);
                    prevNode = insertedNode;
                }
            }

            internal override void internalClearChildren() {
                while (m_firstChild != null)
                    _detachNode(m_firstChild, null);
            }

            /// <summary>
            /// Checks if any node in the path of XML tree hierarchy between this node and
            /// <paramref name="declaringNode"/> declares a namespace prefix that hides a namespace
            /// declaration <paramref name="ns"/> declared by <paramref name="declaringNode"/>.
            /// </summary>
            ///
            /// <param name="ns">The namespace declaration.</param>
            /// <param name="declaringNode">The node, which must be an ancestor of this node, that
            /// declares <paramref name="ns"/>.</param>
            /// <returns>True if no element in the hierarchy path between this node and
            /// <paramref name="declaringNode"/> declares a namespace prefix with a URI different from
            /// that of <paramref name="ns"/>, otherwise false.</returns>
            private bool _doesNotHaveHiddenPrefix(ASNamespace ns, _ElementNode declaringNode) {
                string prefix = ns.prefix, uri = ns.uri;

                for (_ElementNode cur = this; cur != declaringNode; cur = cur.m_parent) {
                    for (int i = 0, n = cur.m_nsdecls.length; i < n; i++) {
                        if (cur.m_nsdecls[i].prefix == prefix && cur.m_nsdecls[i].uri != uri)
                            return false;
                    }
                }

                return true;
            }

            protected override string internalFindPrefixForName(ASQName name, bool isAttr) {
                // We don't lock here because if multiple threads reach this point, they
                // will get the same prefix.
                // [Unless this node or one of its ancestors is modified, in which case thread
                // safety becomes the user's responsibility]

                for (_ElementNode cur = this; cur != null; cur = cur.m_parent) {
                    for (int i = 0, n = cur.m_nsdecls.length; i < n; i++) {
                        ASNamespace ns = cur.m_nsdecls[i];
                        if (ns.uri != name.uri)
                            continue;

                        if (isAttr && ns.prefix.Length == 0)
                            // Don't allocate the empty string prefix to attributes: attributes
                            // which do not have nonempty prefixes are always in the public namespace.
                            continue;

                        if (!_doesNotHaveHiddenPrefix(ns, cur))
                            continue;

                        return ns.prefix;
                    }
                }

                return null;
            }

            public override ASAny @namespace(OptionalParam<ASAny> prefix = default) {
                if (!prefix.isSpecified)
                    return name().getNamespace();

                string prefixStr = ASAny.AS_convertString(prefix.value);

                for (_ElementNode cur = this; cur != null; cur = cur.m_parent) {
                    int nsIndex = _findNamespaceByPrefix(cur.m_nsdecls.asSpan(), prefixStr);
                    if (nsIndex != -1)
                        return cur.m_nsdecls[nsIndex];
                }

                return ASAny.undefined;
            }

            public override ASArray inScopeNamespaces() {
                DynamicArray<ASNamespace> nsList = new DynamicArray<ASNamespace>();

                // Add declarations of this node
                _ElementNode cur = this;
                for (int i = 0; i < cur.m_nsdecls.length; i++)
                    nsList.add(cur.m_nsdecls[i]);

                // Add declarations from ancestor nodes.
                for (cur = cur.m_parent; cur != null; cur = cur.m_parent) {
                    var prefixesToCheck = nsList.asSpan();
                    var newNamespaces = cur.m_nsdecls.asSpan();

                    for (int i = 0; i < newNamespaces.Length; i++) {
                        if (_findNamespaceByPrefix(prefixesToCheck, newNamespaces[i].prefix) == -1)
                            nsList.add(newNamespaces[i]);
                    }
                }

                return ASArray.fromObjectSpan<ASNamespace>(nsList.asSpan());
            }

            public override ASArray namespaceDeclarations() {
                _ElementNode cur = this;

                if (cur.m_nsdecls.length == 0)
                    return new ASArray();

                // Make a copy of the namespace array because namespaces that are declared
                // by ancestors need to be removed.
                ASNamespace[] thisNodeDecls = m_nsdecls.toArray(true);
                bool isAnyDeclRemoved = false;

                // Check for declarations of ancestor nodes and remove them.
                for (cur = cur.m_parent; cur != null; cur = cur.m_parent) {
                    var ancestorDecls = cur.m_nsdecls.asSpan();

                    for (int i = 0; i < ancestorDecls.Length; i++) {
                        int nsIndex = _findNamespaceByPrefix(thisNodeDecls, ancestorDecls[i].prefix);

                        if (nsIndex != -1 && thisNodeDecls[nsIndex].uri == ancestorDecls[i].uri) {
                            thisNodeDecls[nsIndex] = null;
                            isAnyDeclRemoved = true;
                        }
                    }
                }

                Span<ASNamespace> thisNodeDeclsSpan = thisNodeDecls;
                if (isAnyDeclRemoved)
                    thisNodeDeclsSpan = DataStructureUtil.compactNulls(thisNodeDeclsSpan);

                return ASArray.fromObjectSpan<ASNamespace>(thisNodeDeclsSpan);
            }

            /// <summary>
            /// Finds the previous sibling of an attribute or child of this node.
            /// </summary>
            /// <param name="node">An attribute or child of this node.</param>
            /// <returns>The previous sibling of <paramref name="node"/>, or null if it is the first
            /// child or attribute.</returns>
            private ASXML _findPreviousSibling(ASXML node) {
                ASXML curNode = node.isAttribute ? m_firstAttr : m_firstChild;

                if (curNode == node)
                    return null;

                while (curNode != null) {
                    if (curNode.m_next == node)
                        return curNode;
                    curNode = curNode.m_next;
                }

                // If we reach this point, `node` is not an attribute/child of this node.
                return null;
            }

            /// <summary>
            /// Removes an attribute or child node from this node.
            /// </summary>
            /// <returns>The next sibling of <paramref name="node"/>, or null if it is the last node.</returns>
            /// <param name="node">The node to be removed.</param>
            /// <param name="prevSibling">The previous sibling of <paramref name="node"/>.</param>
            private ASXML _detachNode(ASXML node, ASXML prevSibling) {
                bool isAttr = node.isAttribute;
                ASXML next = node.m_next;

                node.m_next = null;
                node.m_parent = null;

                if (next == null && !isAttr)
                    m_lastChild = prevSibling;

                if (prevSibling != null)
                    prevSibling.m_next = next;
                else if (isAttr)
                    m_firstAttr = next;
                else
                    m_firstChild = next;

                return next;
            }

            /// <summary>
            /// Replaces an attribute or child of this node with a new one.
            /// </summary>
            ///
            /// <param name="node">The node to be replaced.</param>
            /// <param name="prevSibling">The previous sibling of <paramref name="node"/>, or null
            /// if <paramref name="node"/> is the first attribute or child node.</param>
            /// <param name="newNode">The node that <paramref name="node"/> must be replaced with.</param>
            ///
            /// <remarks>This method does not check if inserting <paramref name="newNode"/> would create
            /// an illegal cycle in the XML tree. Use with caution!</remarks>
            private void _replaceNodeNoCycleCheck(ASXML node, ASXML prevSibling, ASXML newNode) {
                if (node == newNode)
                    return;

                bool isAttr = node.isAttribute;
                ASXML next = node.m_next;

                node.m_next = null;
                node.m_parent = null;

                newNode.m_parent = this;
                newNode.m_next = next;

                if (next == null && !isAttr)
                    m_lastChild = newNode;

                if (prevSibling != null)
                    prevSibling.m_next = newNode;
                else if (isAttr)
                    m_firstAttr = newNode;
                else
                    m_firstChild = newNode;
            }

            /// <summary>
            /// Creates a shallow copy of the given node. If the node is an element, its
            /// attributes and namespace declarations are copied, but the returned copy has no children.
            /// </summary>
            /// <returns>A shallow copy of this node.</returns>
            /// <param name="node">The node for which to create a copy.</param>
            /// <param name="parent">The node to be set as the parent of the copy.</param>
            private static ASXML _makeShallowCopy(ASXML node, ASXML parent) {
                if (!(node is _ElementNode elem))
                    return new _TextNode(node.m_name, parent, node.m_nodeType, node.nodeText);

                _ElementNode newElem = new _ElementNode(node.m_name, parent);
                ref ASXML newElemAttrTail = ref newElem.m_firstAttr;

                for (ASXML attr = elem.m_firstAttr; attr != null; attr = attr.m_next) {
                    ASXML newAttr = new _TextNode(attr.m_name, newElem, XMLNodeType.ATTRIBUTE, attr.nodeText);
                    newElemAttrTail = newAttr;
                    newElemAttrTail = ref newAttr.m_next;
                }

                newElem.m_nsdecls = new DynamicArray<ASNamespace>(elem.m_nsdecls.toArray(true), elem.m_nsdecls.length);

                return newElem;
            }

            private void _getAssignTargetAndClear(in XMLGenName searchGenName, out ASXML targetNode, out ASXML targetNodePrev) {
                ASXML firstNode = searchGenName.isAttr ? m_firstAttr : m_firstChild;

                bool isMultiNamespace = searchGenName.isMultiname;
                string uri = searchGenName.uri;

                XMLNodeType targetType = searchGenName.isAttr ? XMLNodeType.ATTRIBUTE : XMLNodeType.ELEMENT;

                // If we are searching for an attribute and the name is fully qualified, there is only
                // one node that can match.
                bool hasSingleTarget = searchGenName.isAttr && !isMultiNamespace && uri != null && searchGenName.localName != null;

                if (isMultiNamespace && searchGenName.nsSet.containsAny) {
                    uri = null;
                    isMultiNamespace = false;
                }

                if (!isMultiNamespace && uri == null && searchGenName.localName == null) {
                    // Special case for the "any" name.
                    (targetNodePrev, targetNode) = (null, firstNode);
                    if (firstNode != null) {
                        while (firstNode.m_next != null)
                            _detachNode(firstNode.m_next, firstNode);
                    }
                    return;
                }

                (targetNodePrev, targetNode) = (null, null);
                ASXML curNode = firstNode, curNodePrev = null;

                while (curNode != null) {
                    ASQName curName = curNode.m_name;

                    if (curNode.m_nodeType != targetType
                        || curName.localName != searchGenName.localName
                        || (isMultiNamespace && !searchGenName.nsSet.contains(curName.uri) && curName.uri != uri)
                        || (!isMultiNamespace && uri != null && curName.uri != uri))
                    {
                        (curNodePrev, curNode) = (curNode, curNode.m_next);
                    }
                    else if (targetNode != null) {
                        // Remove any matching nodes after the first one.
                        curNode = _detachNode(curNode, curNodePrev);
                    }
                    else {
                        (targetNode, targetNodePrev) = (curNode, curNodePrev);
                        (curNodePrev, curNode) = (curNode, curNode.m_next);

                        if (hasSingleTarget)
                            return;
                    }
                }
            }

            public override ASXML createChildNode(
                XMLNodeType nodeType, ASQName nodeName = null, string nodeText = null)
            {
                if (nodeType == XMLNodeType.ATTRIBUTE || nodeType == XMLNodeType.ELEMENT
                    || nodeType == XMLNodeType.PROCESSING_INSTRUCTION)
                {
                    // Check name validity
                    if (nodeName == null || !XMLHelper.isValidName(nodeName.localName))
                        return null;
                }

                if (nodeType == XMLNodeType.PROCESSING_INSTRUCTION
                    && nodeName.uri != null && nodeName.uri.Length != 0)
                {
                    nodeName = new ASQName("", nodeName.localName);
                }
                else if (nodeType == XMLNodeType.ELEMENT) {
                    if (nodeName.uri == null)
                        nodeName = new ASQName(ASNamespace.getDefault(), nodeName.localName);
                }
                else if (nodeType == XMLNodeType.ATTRIBUTE) {
                    if (nodeName.uri == null) {
                        nodeName = new ASQName("", nodeName.localName);
                    }
                    else if (nodeName.prefix != null
                        && ((nodeName.prefix.Length == 0 && nodeName.uri.Length != 0)
                            || nodeName.prefix == "xmlns"))
                    {
                        nodeName = ASQName.unsafeCreate(null, nodeName.uri, nodeName.localName);
                    }
                }
                else {
                    nodeName = null;
                }

                ASXML newNode;

                if (nodeType == XMLNodeType.ATTRIBUTE) {
                    if (!_checkAttributeName(nodeName))
                        return null;

                    newNode = new _TextNode(nodeName, this, nodeType, nodeText);
                    newNode.m_next = m_firstAttr;
                    m_firstAttr = newNode;
                }
                else {
                    if (nodeType == XMLNodeType.ELEMENT)
                        newNode = new _ElementNode(nodeName, this);
                    else
                        newNode = new _TextNode(nodeName, this, nodeType, nodeText);

                    newNode.m_next = null;
                    internalInsertChildAfter(m_lastChild, newNode, false);
                }

                if (nodeName == null || nodeName.prefix == null || nodeName.uri.Length == 0)
                    return newNode;

                // Add a namespace declaration for the node name prefix, if there is no
                // declaration on any ancestor.

                bool foundPrefix = false;

                for (_ElementNode cur = this; cur != null && !foundPrefix; cur = cur.m_parent) {
                    int nsIndex = _findNamespaceByPrefix(cur.m_nsdecls.asSpan(), nodeName.prefix);
                    if (nsIndex != -1) {
                        foundPrefix = cur.m_nsdecls[nsIndex].uri == nodeName.uri;
                        break;
                    }
                }

                if (!foundPrefix) {
                    if (nodeType == XMLNodeType.ELEMENT)
                        newNode.addNamespace(nodeName.getNamespace());
                    else
                        addNamespace(nodeName.getNamespace());
                }

                return newNode;
            }

            internal override void internalSetPropGenName(in XMLGenName genName, ASAny value) {
                // See: ECMA-357, sec. 9.1.1.2, [[Put]]
                // The case where the name is an array index is handled by callers (e.g. AS_trySetProperty)

                if (genName.isAttr) {
                    // [[Put]] step 6

                    if (genName.localName == null)
                        return;

                    string attrString = XMLHelper.objectToAttrString(value);
                    _getAssignTargetAndClear(genName, out ASXML attribute, out _);

                    if (attribute == null) {
                        // Create a new attribute.
                        string uri = genName.uri, prefix = genName.prefix;

                        if (genName.isMultiname || uri == null)
                            uri = "";

                        if (!XMLHelper.isValidName(genName.localName) || (genName.localName == "xmlns" && uri.Length == 0))
                            return;

                        if (prefix != null && ((prefix.Length == 0 && uri.Length != 0) || prefix == "xmlns"))
                            // Invalid prefix for attribute.
                            prefix = null;

                        var qname = ASQName.unsafeCreate(prefix, uri, genName.localName);
                        attribute = new _TextNode(qname, this, XMLNodeType.ATTRIBUTE, null);
                        attribute.m_next = m_firstAttr;
                        m_firstAttr = attribute;

                        if (qname.prefix != null && qname.uri.Length != 0)
                            addNamespace(qname.getNamespace());
                    }

                    attribute.nodeText = attrString;
                }
                else {
                    // The non-attribute case. This corresponds to [[Put]] steps 7-14.

                    ASXML valueXml = value.value as ASXML;
                    ASXMLList valueXmlList = value.value as ASXMLList;

                    if (valueXmlList != null && valueXmlList.length() == 0) {
                        // Special case for empty XMLList.
                        internalDeletePropGenName(genName);
                        return;
                    }

                    if (genName.localName != null && !XMLHelper.isValidName(genName.localName))
                        return;

                    // A primitive assignment is done when the local name is not null, and when the
                    // value is one of the following: anything other than XML/XMLList, an XML object
                    // representing a text or attribute node, or an XMLList having one item which is
                    // a text or attribute node. (This is from [[Put]] step 10; the last two cases
                    // follow from step 3)

                    string primitiveString = null;

                    if (genName.localName != null)
                        primitiveString = XMLHelper.tryGetStringFromObjectOrNode(value);

                    _getAssignTargetAndClear(genName, out ASXML target, out ASXML targetPrevSibling);

                    if (primitiveString != null) {
                        // If we are doing a primitive assign and the node does not exist, create
                        // a new element with the property name and append it. ([[Put]] step 12b)

                        if (target == null) {
                            string uri = genName.uri, prefix = genName.prefix;

                            if (genName.isMultiname || uri == null) {
                                var defaultNs = ASNamespace.getDefault();
                                (uri, prefix) = (defaultNs.uri, defaultNs.prefix);
                            }

                            ASQName nodeName = ASQName.unsafeCreate(prefix, uri, genName.localName);
                            target = new _ElementNode(nodeName, this);
                            internalInsertChildAfter(m_lastChild, target, mustCopy: false);

                            if (nodeName.prefix != null && nodeName.uri.Length != 0)
                                target.addNamespace(nodeName.getNamespace());
                        }

                        target.internalClearChildren();

                        if (primitiveString.Length != 0) {
                            target.internalInsertChildAfter(
                                null, new _TextNode(null, null, XMLNodeType.TEXT, primitiveString), mustCopy: false
                            );
                        }

                        return;
                    }

                    ASXML replacementNode = valueXml;
                    bool mustCopy = true;

                    if (replacementNode == null) {
                        if (valueXmlList != null) {
                            replacementNode = valueXmlList[0];
                        }
                        else {
                            replacementNode = new _TextNode(null, null, XMLNodeType.TEXT, ASAny.AS_convertString(value));
                            mustCopy = false;
                        }
                    }

                    if (target != null) {
                        // In general _copyOrCheckChildToBeInserted may remove `replacementNode` from
                        // its existing parent, which may change the previous sibling of `target`.
                        // But it will never happen in this particular case because either `mustCopy`
                        // is true or `replacementNode` does not have an existing parent.

                        replacementNode = _copyOrCheckChildToBeInserted(replacementNode, mustCopy);
                        _replaceNodeNoCycleCheck(target, targetPrevSibling, replacementNode);
                    }
                    else {
                        internalInsertChildAfter(m_lastChild, replacementNode, mustCopy);
                    }

                    if (valueXmlList != null && valueXmlList.length() > 1) {
                        // If we have an XMLList with more than one item, we need to splice in the remaining items.
                        var rest = valueXmlList.getItems().asSpan(1);
                        internalInsertChildrenAfter(replacementNode, rest, mustCopy: true);
                    }
                }
            }

            internal override void internalDeletePropGenName(in XMLGenName searchGenName) {
                bool isMultiNamespace = searchGenName.isMultiname;
                string uri = searchGenName.uri;

                XMLNodeType targetType = searchGenName.isAttr ? XMLNodeType.ATTRIBUTE : XMLNodeType.ELEMENT;

                // If we are searching for an attribute and the name is fully qualified, there is only
                // one node that can match.
                bool singleOnly = searchGenName.isAttr && !isMultiNamespace && uri != null && searchGenName.localName != null;

                ASXML firstNode = searchGenName.isAttr ? m_firstAttr : m_firstChild;

                if (isMultiNamespace && searchGenName.nsSet.containsAny) {
                    uri = null;
                    isMultiNamespace = false;
                }

                if (!isMultiNamespace && uri == null && searchGenName.localName == null) {
                    // Special case for the "any" name.
                    while (firstNode != null)
                        firstNode = _detachNode(firstNode, null);
                    return;
                }

                ASXML prevNode = null, curNode = firstNode;

                while (curNode != null) {
                    ASQName curName = curNode.m_name;

                    if (curNode.m_nodeType != targetType
                        || curName.localName != searchGenName.localName
                        || (isMultiNamespace && !searchGenName.nsSet.contains(curName.uri) && curName.uri != uri)
                        || (!isMultiNamespace && uri != null && curName.uri != uri))
                    {
                        (prevNode, curNode) = (curNode, curNode.m_next);
                        continue;
                    }

                    curNode = _detachNode(curNode, prevNode);

                    if (singleOnly)
                        break;
                }
            }

            internal override void internalDeleteChildOrAttr(ASXML node) =>
                _detachNode(node, _findPreviousSibling(node));

            internal override ASXML internalReplaceChild(ASXML child, ASXML newChild, bool mustCopy) {
                if (child == null || child.m_parent != this)
                    return internalInsertChildAfter(m_lastChild, newChild, mustCopy);

                newChild = _copyOrCheckChildToBeInserted(newChild, mustCopy);
                _replaceNodeNoCycleCheck(child, _findPreviousSibling(child), newChild);

                return newChild;
            }

            internal override void internalReplaceChild(ASXML child, Span<ASXML> newChildren, bool mustCopy) {
                if (child == null || child.m_parent != this) {
                    // Append the new children.
                    // internalInsertChildAfter will update m_lastChild so we don't have to update it here.
                    for (int i = 0; i < newChildren.Length; i++)
                        newChildren[i] = internalInsertChildAfter(m_lastChild, newChildren[i], mustCopy);
                }
                else if (newChildren.Length == 0) {
                    // If nothing is to be inserted, delete the existing node.
                    _detachNode(child, _findPreviousSibling(child));
                }
                else {
                    // Replace the existing child with the first element.
                    ASXML replacementNode = _copyOrCheckChildToBeInserted(newChildren[0], mustCopy);
                    _replaceNodeNoCycleCheck(child, _findPreviousSibling(child), replacementNode);

                    // Splice in the remaining elements from the list.
                    ASXML insertLocation = replacementNode;
                    for (int i = 1; i < newChildren.Length; i++) {
                        newChildren[i] = internalInsertChildAfter(insertLocation, newChildren[i], mustCopy);
                        insertLocation = newChildren[i];
                    }
                }
            }

            internal override void internalGetNamespaceDecls(ref DynamicArray<ASNamespace> list) {
                int existingListSize = list.length;

                for (int i = 0, n = m_nsdecls.length; i < n; i++) {
                    ASNamespace ns = m_nsdecls[i];

                    // Don't add a namespace declaration that is redundant, that is when the most immediate
                    // ancestor having a namespace declaration with the same prefix assigns the same URI to
                    // that prefix.
                    // The ancestor declarations are available in `list` when this method is called, so use
                    // them instead of walking up the XML tree.

                    bool isRedundant = false;
                    for (int j = existingListSize - 1; j >= 0; j--) {
                        if (ns.prefix == list[j].prefix) {
                            isRedundant = ns.uri == list[j].uri;
                            break;
                        }
                    }

                    if (!isRedundant)
                        list.add(m_nsdecls[i]);
                }
            }

            public override ASXML addNamespace(ASAny ns) {
                ASNamespace nameSpace = XMLHelper.objectToNamespace(ns);

                if (nameSpace == null || nameSpace.prefix == null)
                    return this;

                string prefix = nameSpace.prefix;
                if (prefix.Length == 0 && m_name.uri.Length == 0)
                    return this;

                int oldIndex = _findNamespaceByPrefix(m_nsdecls.asSpan(), prefix);

                if (oldIndex == -1) {
                    m_nsdecls.add(nameSpace);

                    bool foundHidingPrefix = false;
                    for (_ElementNode p = m_parent; p != null; p = p.m_parent) {
                        int nsIndex = _findNamespaceByPrefix(p.m_nsdecls.asSpan(), prefix);
                        if (nsIndex != -1) {
                            foundHidingPrefix = p.m_nsdecls[nsIndex].uri != nameSpace.uri;
                            break;
                        }
                    }

                    if (!foundHidingPrefix && prefix.Length != 0)
                        // The new declaration does not hide anything, so no need to update the tree.
                        return this;
                }
                else {
                    if (m_nsdecls[oldIndex].uri == nameSpace.uri)
                        // The namespace declaration already exists.
                        return this;

                    m_nsdecls[oldIndex] = nameSpace;
                }

                var iterator = getDescendantEnumerator(true);

                while (iterator.MoveNext()) {
                    if (!(iterator.Current is _ElementNode cur))
                        continue;

                    if (cur != this) {
                        // Don't update any nodes having a namespace declaration that hides the prefix.
                        if (_findNamespaceByPrefix(cur.m_nsdecls.asSpan(), prefix) != -1) {
                            iterator.stepOverCurrentNode();
                            continue;
                        }
                    }

                    if (cur.m_name.prefix == prefix && cur.m_name.uri.Length != 0)
                        cur.m_name = ASQName.unsafeCreate(null, cur.m_name.uri, cur.m_name.localName);

                    if (prefix.Length != 0) {
                        for (ASXML attr = cur.m_firstAttr; attr != null; attr = attr.m_next) {
                            if (attr.m_name.prefix == prefix)
                                attr.m_name = ASQName.unsafeCreate(null, attr.m_name.uri, attr.m_name.localName);
                        }
                    }
                }

                return this;
            }

            public override ASXML copy() {
                ASXML cur = this;
                ASXML copyCur = _makeShallowCopy(this, null);

                while (true) {
                    if (cur is _ElementNode curElement && curElement.m_firstChild != null) {
                        // Descend into the first child.
                        _ElementNode copyCurElement = (_ElementNode)copyCur;
                        copyCurElement.m_firstChild = _makeShallowCopy(curElement.m_firstChild, copyCurElement);
                        cur = curElement.m_firstChild;
                        copyCur = copyCurElement.m_firstChild;
                        continue;
                    }

                    if (cur == this)
                        break;

                    bool rootReached = false;
                    while (cur.m_next == null) {
                        cur = cur.m_parent;

                        copyCur.m_parent.m_lastChild = copyCur;
                        copyCur = copyCur.m_parent;

                        if (cur == this) {
                            rootReached = true;
                            break;
                        }
                    }

                    if (rootReached)
                        break;

                    ASXML newNode = _makeShallowCopy(cur.m_next, copyCur.m_parent);
                    copyCur.m_next = newNode;
                    cur = cur.m_next;
                    copyCur = newNode;
                }

                // Copy namespace declarations from ancestors.
                var copyElement = (_ElementNode)copyCur;

                for (_ElementNode p = m_parent; p != null; p = p.m_parent) {
                    for (int i = 0; i < p.m_nsdecls.length; i++) {
                        bool prefixExists = _findNamespaceByPrefix(copyElement.m_nsdecls.asSpan(), p.m_nsdecls[i].prefix) != -1;
                        if (!prefixExists)
                            copyElement.m_nsdecls.add(p.m_nsdecls[i]);
                    }
                }

                return copyElement;
            }

            public override ASXML normalize() {
                DynamicArray<string> tempList = new DynamicArray<string>();
                DescendantEnumerator iterator = getDescendantEnumerator(true);

                while (iterator.MoveNext()) {
                    if (!(iterator.Current is _ElementNode curElement))
                        continue;

                    bool hasSubElement = false;
                    ASXML prevChild = null, curChild = curElement.m_firstChild;

                    while (curChild != null) {
                        if (!curChild.isTextOrCDATA) {
                            hasSubElement |= curChild.isElement;
                            (prevChild, curChild) = (curChild, curChild.m_next);
                            continue;
                        }

                        // Find a consecutive run of text nodes starting at the current one.

                        int runLength = curChild.nodeText.Length;
                        ASXML endOfRun = curChild.m_next;

                        while (endOfRun != null && endOfRun.isTextOrCDATA) {
                            runLength += endOfRun.nodeText.Length;
                            endOfRun = endOfRun.m_next;
                        }

                        if (runLength == 0) {
                            // The run is empty. Delete all the nodes in it.
                            while (curChild != endOfRun)
                                curChild = _detachNode(curChild, prevChild);
                            continue;
                        }

                        if (curChild.m_next == endOfRun) {
                            // The run has only one node, no merging needed.
                            (prevChild, curChild) = (curChild, curChild.m_next);
                            continue;
                        }

                        string mergedText;

                        if (curChild.m_next.m_next == endOfRun) {
                            mergedText = curChild.nodeText + curChild.m_next.nodeText;
                            _detachNode(curChild.m_next, curChild);
                        }
                        else {
                            tempList.add(curChild.nodeText);

                            while (curChild.m_next != endOfRun) {
                                tempList.add(curChild.m_next.nodeText);
                                _detachNode(curChild.m_next, curChild);
                            }

                            mergedText = String.Join("", tempList.getUnderlyingArray(), 0, tempList.length);
                            tempList.clear();
                        }

                        curChild.nodeText = mergedText;
                        (prevChild, curChild) = (curChild, curChild.m_next);
                    }

                    if (!hasSubElement) {
                        // We didn't find a child element in the normalization pass, so recursing is unnecessary.
                        iterator.stepOverCurrentNode();
                    }
                }

                return this;
            }

            public override ASXML removeNamespace(ASAny ns) {
                ASNamespace nameSpace = XMLHelper.objectToNamespace(ns);

                if (nameSpace.uri.Length == 0)
                    // We can't remove this namespace.
                    return this;

                string prefix = nameSpace.prefix;
                if (prefix == null) {
                    // Search for a prefix.
                    int nsDeclIndex = -1;
                    for (int i = 0; i < m_nsdecls.length; i++) {
                        if (m_nsdecls[i].uri == nameSpace.uri
                            && (nameSpace.prefix == null || nameSpace.prefix == m_nsdecls[i].prefix))
                        {
                            nsDeclIndex = i;
                            break;
                        }
                    }
                    if (nsDeclIndex != -1)
                        prefix = m_nsdecls[nsDeclIndex].prefix;
                }

                if (prefix == null)
                    return this;

                DescendantEnumerator iterator = getDescendantEnumerator(true);

                while (iterator.MoveNext()) {
                    if (!(iterator.Current is _ElementNode curNode))
                        continue;

                    int nsDeclIndex = _findNamespaceByPrefix(curNode.m_nsdecls.asSpan(), prefix);
                    if (nsDeclIndex != -1) {
                        if (curNode.m_nsdecls[nsDeclIndex].uri != nameSpace.uri) {
                            // Hidden prefix - don't enter.
                            iterator.stepOverCurrentNode();
                            continue;
                        }
                        curNode.m_nsdecls.removeRange(nsDeclIndex, 1);
                    }

                    if (curNode.m_name.prefix == prefix)
                        curNode.m_name = ASQName.unsafeCreate(null, curNode.m_name.uri, curNode.m_name.localName);

                    if (prefix.Length != 0) {
                        for (ASXML attr = curNode.m_firstAttr; attr != null; attr = attr.m_next) {
                            if (attr.m_name.prefix == prefix)
                                attr.m_name = ASQName.unsafeCreate(null, attr.m_name.uri, attr.m_name.localName);
                        }
                    }
                }

                return this;
            }

            public override ASXML replace(ASAny name, ASAny newValue) {
                var genName = XMLGenName.fromObject(name, 0);

                bool mustCopy = true;
                ASXMLList valueXmlList = newValue.value as ASXMLList;

                string replacementText = XMLHelper.tryGetStringFromObjectOrNode(newValue);
                ASXML replacementNode;

                if (replacementText != null) {
                    replacementNode = new _TextNode(null, null, XMLNodeType.TEXT, replacementText);
                    mustCopy = false;
                }
                else if (valueXmlList != null) {
                    replacementNode = (valueXmlList.length() > 0) ? valueXmlList[0] : null;
                }
                else {
                    replacementNode = (ASXML)newValue;
                }

                ASXML targetNode;
                ASXML targetPrevSibling;

                if (genName.isIndex) {
                    int index = 0;
                    (targetPrevSibling, targetNode) = (null, m_firstChild);
                    while (targetNode != null && index < genName.index) {
                        index++;
                        (targetPrevSibling, targetNode) = (targetNode, targetNode.m_next);
                    }
                }
                else {
                    _getAssignTargetAndClear(genName, out targetNode, out targetPrevSibling);
                    if (targetNode == null)
                        return this;
                }

                if (valueXmlList != null && valueXmlList.length() == 0) {
                    // Special case for an empty XMLList.
                    _detachNode(targetNode, targetPrevSibling);
                    return this;
                }

                if (targetNode != null) {
                    // In general _copyOrCheckChildToBeInserted may remove `replacementNode` from
                    // its existing parent, which may change the previous sibling of `target`.
                    // But it will never happen in this particular case because either `mustCopy`
                    // is true or `replacementNode` does not have an existing parent.

                    replacementNode = _copyOrCheckChildToBeInserted(replacementNode, mustCopy);
                    _replaceNodeNoCycleCheck(targetNode, targetPrevSibling, replacementNode);
                }
                else {
                    internalInsertChildAfter(m_lastChild, replacementNode, mustCopy);
                }

                if (valueXmlList != null) {
                    // Splice in the remaining items from an XMLList.
                    var rest = valueXmlList.getItems().asSpan(1);
                    internalInsertChildrenAfter(replacementNode, rest, mustCopy: true);
                }

                return this;
            }

        }

        #region Iterators

        /// <summary>
        /// Used for iterating over an XML node's attributes or children.
        /// </summary>
        /// <seealso cref="ASXML.getChildEnumerator"/>
        /// <seealso cref="ASXML.getAttributeEnumerator"/>
        public struct Enumerator : IEnumerable<ASXML>, IEnumerator<ASXML> {

            private ASXML m_current;
            private bool m_isActive;

            internal Enumerator(ASXML node) {
                m_current = node;
                m_isActive = false;
            }

            /// <summary>
            /// Gets an enumerator for this <see cref="IEnumerable{ASXML}"/> instance.
            /// </summary>
            /// <returns>An enumerator for this <see cref="IEnumerable{ASXML}"/> instance.</returns>
            public Enumerator GetEnumerator() {
                if (m_isActive)
                    throw new InvalidOperationException();
                return this;
            }

            /// <summary>
            /// Moves the iterator to the next node in the sequence.
            /// </summary>
            /// <returns>False if the iteration has ended, otherwise true.</returns>
            public bool MoveNext() {
                if (!m_isActive)
                    m_isActive = true;
                else
                    m_current = m_current.m_next;
                return m_current != null;
            }

            /// <summary>
            /// Gets the node at the iterator's current position.
            /// </summary>
            public ASXML Current => m_current;

            /// <exclude/>
            public void Reset() => throw new NotImplementedException();

            /// <exclude/>
            public void Dispose() { }

            /// <summary>
            /// Gets an enumerator for this <see cref="IEnumerable{ASXML}"/> instance.
            /// </summary>
            /// <returns>An enumerator for this <see cref="IEnumerable{ASXML}"/> instance.</returns>
            IEnumerator<ASXML> IEnumerable<ASXML>.GetEnumerator() => GetEnumerator();

            /// <summary>
            /// Gets an enumerator for this <see cref="IEnumerable"/> instance.
            /// </summary>
            /// <returns>An enumerator for this <see cref="IEnumerable"/> instance.</returns>
            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

            /// <summary>
            /// Gets the node at the iterator's current position.
            /// </summary>
            object IEnumerator.Current => m_current;

        }

        /// <summary>
        /// Used for iterating over an XML node's descendants. This performs a depth-first
        /// traversal of the XML node's tree.
        /// </summary>
        /// <seealso cref="ASXML.getDescendantEnumerator"/>
        public struct DescendantEnumerator : IEnumerable<ASXML>, IEnumerator<ASXML> {

            private ASXML m_current;
            private bool m_stepOverCurrent;
            private int m_currentDepth;

            internal DescendantEnumerator(ASXML node, bool includeRoot) {
                m_current = includeRoot ? node : node.internalGetFirstChild();
                m_currentDepth = includeRoot ? -1 : -2;
                m_stepOverCurrent = false;
            }

            /// <summary>
            /// Gets an enumerator for this <see cref="IEnumerable{ASXML}"/> instance.
            /// </summary>
            /// <returns>An enumerator for this <see cref="IEnumerable{ASXML}"/> instance.</returns>
            public DescendantEnumerator GetEnumerator() {
                if (m_currentDepth >= 0)
                    throw new InvalidOperationException();
                return this;
            }

            /// <summary>
            /// Moves the iterator to the next node in the sequence.
            /// </summary>
            /// <returns>False if the iteration has ended, otherwise true.</returns>
            public bool MoveNext() {
                if (m_currentDepth < 0) {
                    m_currentDepth = (m_currentDepth == -2) ? 1 : 0;
                    return m_current != null;
                }

                bool stepOver = m_stepOverCurrent;
                m_stepOverCurrent = false;

                if (m_current.isElement && !stepOver) {
                    ASXML firstChild = m_current.internalGetFirstChild();
                    if (firstChild != null) {
                        m_current = firstChild;
                        m_currentDepth++;
                        return true;
                    }
                }

                if (m_currentDepth == 0)
                    return false;

                while (m_current.m_next == null) {
                    m_current = m_current.m_parent;
                    m_currentDepth--;
                    if (m_currentDepth == 0)
                        return false;
                }

                m_current = m_current.m_next;
                return true;
            }

            /// <summary>
            /// Gets the node at the iterator's current position.
            /// </summary>
            public ASXML Current => m_current;

            /// <exclude/>
            public void Reset() => throw new NotImplementedException();

            /// <exclude/>
            public void Dispose() { }

            /// <summary>
            /// Gets the depth at the iterator's current position.
            /// </summary>
            /// <value>The current depth. 0 corresponds to the root element, 1 corresponds to a
            /// child of the root, 2 to a grandchild of the root and so on.</value>
            public int currentDepth => m_currentDepth;

            /// <summary>
            /// Prevents the iterator from recursing into the current node, if it is an element
            /// with children.
            /// </summary>
            public void stepOverCurrentNode() {
                m_stepOverCurrent = true;
            }

            /// <summary>
            /// Gets an enumerator for this <see cref="IEnumerable{ASXML}"/> instance.
            /// </summary>
            /// <returns>An enumerator for this <see cref="IEnumerable{ASXML}"/> instance.</returns>
            IEnumerator<ASXML> IEnumerable<ASXML>.GetEnumerator() => GetEnumerator();

            /// <summary>
            /// Gets an enumerator for this <see cref="IEnumerable"/> instance.
            /// </summary>
            /// <returns>An enumerator for this <see cref="IEnumerable"/> instance.</returns>
            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

            /// <summary>
            /// Gets the node at the iterator's current position.
            /// </summary>
            object IEnumerator.Current => m_current;

        }

        #endregion

    }

}
