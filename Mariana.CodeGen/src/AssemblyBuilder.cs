using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Metadata;
using System.Reflection.Metadata.Ecma335;
using System.Reflection.PortableExecutable;
using Mariana.Common;

namespace Mariana.CodeGen {

    /// <summary>
    /// Represents a dynamic assembly being generated by CodeGen.
    /// </summary>
    public sealed class AssemblyBuilder {

        private MetadataContext m_metadataContext;

        private DynamicArray<TypeBuilder> m_typeBuilders;

        private HashSet<TypeName> m_typeDefNames = new HashSet<TypeName>();

        private object m_typeBuildersLock = new object();

        private PEHeaderBuilder? m_peHeader;

        private EntityHandle m_entryPoint;

        private bool m_isPEFileCreated;

        /// <summary>
        /// Creates a new instance of <see cref="AssemblyBuilder"/>.
        /// </summary>
        /// <param name="name">The name of the assembly.</param>
        /// <param name="version">The assembly version. If this is null, the version 0.0.0.0
        /// is used.</param>
        /// <param name="culture">The assembly culture, or null if there is no culture associated
        /// with the assembly.</param>
        /// <param name="flags">A set of bit flags from <see cref="AssemblyFlags"/>.</param>
        /// <param name="hashAlgorithm">The hash algorithm for the assembly. This is ignored for now,
        /// as emitting multi-file assemblies is not supported.</param>
        /// <param name="publicKey">The public key for the assembly, null if there is no public key.</param>
        /// <param name="mainModuleName">The name of the manifest module, null to use the assembly
        /// name.</param>
        /// <param name="moduleVersionId">A GUID that uniquely identifies the current version of
        /// the main module. If not specified, a random value is used.</param>
        public AssemblyBuilder(
            string name,
            Version? version = null,
            string? culture = null,
            AssemblyFlags flags = 0,
            AssemblyHashAlgorithm hashAlgorithm = AssemblyHashAlgorithm.None,
            byte[]? publicKey = null,
            string? mainModuleName = null,
            Guid moduleVersionId = default
        ) {
            if (name == null || name.Length == 0)
                throw new ArgumentException("Assembly name must not be null or empty.", nameof(name));

            version ??= new Version(0, 0, 0, 0);

            var metadataBuilder = new MetadataBuilder();
            m_metadataContext = new MetadataContext(metadataBuilder);

            StringHandle nameHandle = m_metadataContext.getStringHandle(name);
            StringHandle cultureHandle = m_metadataContext.getStringHandle(culture);
            BlobHandle publicKeyHandle = m_metadataContext.getBlobHandle(publicKey);

            metadataBuilder.AddAssembly(nameHandle, version, cultureHandle, publicKeyHandle, flags, hashAlgorithm);

            StringHandle moduleNameHandle = (mainModuleName != null && mainModuleName.Length != 0)
                ? metadataBuilder.GetOrAddString(mainModuleName)
                : nameHandle;

            if (moduleVersionId.Equals(default(Guid)))
                moduleVersionId = Guid.NewGuid();

            GuidHandle mvid = metadataBuilder.GetOrAddGuid(moduleVersionId);

            metadataBuilder.AddModule(0, moduleNameHandle, mvid, MetadataTokens.GuidHandle(0), MetadataTokens.GuidHandle(0));

            // <Module> should be the first row in TypeDef
            metadataBuilder.AddTypeDefinition(
                attributes: TypeAttributes.Class,
                @namespace: m_metadataContext.getStringHandle(null),
                name: m_metadataContext.getStringHandle("<Module>"),
                baseType: MetadataTokens.TypeDefinitionHandle(0),
                fieldList: MetadataTokens.FieldDefinitionHandle(1),
                methodList: MetadataTokens.MethodDefinitionHandle(1)
            );
        }

        /// <summary>
        /// Returns the metadata context for this <see cref="AssemblyBuilder"/>.
        /// </summary>
        public MetadataContext metadataContext => m_metadataContext;

        /// <summary>
        /// Defines a type in this assembly and returns a <see cref="TypeBuilder"/> instance for
        /// that type.
        /// </summary>
        ///
        /// <param name="name">The name of the type.</param>
        /// <param name="attrs">The attributes of the type.</param>
        /// <param name="isValueType">True if the type is a value type (including enum
        /// types). If this is true, the <see cref="TypeAttributes.Sealed"/> flag is added
        /// to <paramref name="attrs"/>.</param>
        /// <param name="genParamCount">The number of generic type parameters for the type,
        /// or zero if the type should not be generic.</param>
        ///
        /// <returns>A <see cref="TypeBuilder"/> that can be used to emit the definition
        /// of the type.</returns>
        ///
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="genParamCount"/> is less
        /// than 0.</exception>
        /// <exception cref="ArgumentException"><paramref name="name"/> has a name that is null
        /// or an empty string or a namespace that is an empty string; or <paramref name="attrs"/>
        /// has one or more of the following flags set: Any of the 'NestedXXX' access flags, or
        /// both Interface and Sealed flags set together.</exception>
        /// <exception cref="NotSupportedException"><paramref name="attrs"/> has the
        /// <see cref="TypeAttributes.ExplicitLayout"/> flag set.</exception>
        public TypeBuilder defineType(
            TypeName name, TypeAttributes attrs, bool isValueType = false, int genParamCount = 0)
        {
            if (m_isPEFileCreated)
                throw new InvalidOperationException("The PE file for this assembly has already been created.");

            if (name.name == null || name.name.Length == 0)
                throw new ArgumentException("Type name must not be null or an empty string.", nameof(name));

            if (name.ns != null && name.ns.Length == 0)
                throw new ArgumentException("Type namespace must not be an empty string.", nameof(name));

            if (genParamCount < 0)
                throw new ArgumentOutOfRangeException(nameof(genParamCount));

            if (isValueType)
                attrs |= TypeAttributes.Sealed;

            _validateTypeAttributes(attrs);

            // +2 because the first row in TypeDef is the special <Module> type, which does
            // not have an associated TypeBuilder.
            var handle = MetadataTokens.TypeDefinitionHandle(m_typeBuilders.length + 2);

            var typeBuilder = new TypeBuilder(name, attrs, isValueType, genParamCount, m_metadataContext, handle);

            lock (m_typeBuildersLock) {
                if (!m_typeDefNames.Add(name)) {
                    throw new ArgumentException(
                        "A type with the name '" + name.ToString() + "' already exists in this assembly.", nameof(name));
                }

                m_typeBuilders.add(typeBuilder);
                return typeBuilder;
            }
        }

        private void _validateTypeAttributes(TypeAttributes attrs) {
            if ((attrs & TypeAttributes.LayoutMask) == TypeAttributes.ExplicitLayout)
                throw new NotSupportedException("Explicit layout is not supported.");

            TypeAttributes visibility = attrs & TypeAttributes.VisibilityMask;

            if (visibility != TypeAttributes.Public && visibility != TypeAttributes.NotPublic)
                throw new ArgumentException("Type must not have a 'Nested' accessibility.", nameof(attrs));

            if ((attrs & TypeAttributes.Interface) != 0 && (attrs & TypeAttributes.Sealed) != 0)
                throw new ArgumentException("An interface type cannot have the Sealed flag set.", nameof(attrs));
        }

        /// <summary>
        /// Sets the PE file header for the dynamic assembly being emitted.
        /// </summary>
        /// <param name="header">The PE file header for the dynamic assembly.</param>
        /// <remarks>
        /// If no PE header is set using this method before calling <see cref="emit"/>,
        /// a default header is used.
        /// </remarks>
        /// <exception cref="InvalidOperationException">The PE file for the assembly has already been emitted.</exception>
        public void setPEHeader(PEHeaderBuilder header) {
            if (header == null)
                throw new ArgumentNullException(nameof(header));

            if (m_isPEFileCreated)
                throw new InvalidOperationException("The PE file for this assembly has already been created.");

            m_peHeader = header;
        }

        /// <summary>
        /// Sets the method to be used as the entry point for the dynamic assembly being emitted.
        /// </summary>
        /// <param name="methodBuilder">The <see cref="MethodBuilder"/> representing the method that
        /// is to be set as the assembly entry point.</param>
        /// <exception cref="InvalidOperationException">The PE file for the assembly has already been emitted.</exception>
        /// <exception cref="ArgumentException"><paramref name="methodBuilder"/> is from a different assembly.</exception>
        public void setEntryPoint(MethodBuilder methodBuilder) {
            if (methodBuilder == null)
                throw new ArgumentNullException(nameof(methodBuilder));

            if (m_isPEFileCreated)
                throw new InvalidOperationException("The PE file for this assembly has already been created.");

            bool isDeclTypeInThisAssembly = false;
            lock (m_typeBuildersLock) {
                var typeBuilders = m_typeBuilders.asSpan();
                for (int i = 0; i < typeBuilders.Length && !isDeclTypeInThisAssembly; i++)
                    isDeclTypeInThisAssembly = typeBuilders[i] == methodBuilder.declaringType;
            }

            if (!isDeclTypeInThisAssembly)
                throw new ArgumentException("Entry point method is from a different assembly.", nameof(methodBuilder));

            m_entryPoint = methodBuilder.handle;
        }

        /// <summary>
        /// Emits this dynamic assembly to a Portable Executable file image.
        /// </summary>
        /// <returns>An <see cref="AssemblyBuilderEmitResult"/> instance containing the
        /// emitted PE image.</returns>
        /// <remarks>
        /// This method can be called only once. Any subsequent calls will throw an exception.
        /// </remarks>
        public AssemblyBuilderEmitResult emit() {
            if (m_isPEFileCreated)
                throw new InvalidOperationException("The PE file for this assembly has already been created.");

            m_isPEFileCreated = true;

            var tokenMap = new TokenMapping(m_metadataContext.fieldDefRowCount, m_metadataContext.methodDefRowCount);
            BlobBuilder ilStream;

            lock (m_typeBuildersLock) {
                var typeBuilders = m_typeBuilders.asReadOnlyArrayView();
                int currentMethodBodyAddress = 0;

                for (int i = 0; i < typeBuilders.length; i++)
                    currentMethodBodyAddress = typeBuilders[i].assignMethodBodyAddresses(currentMethodBodyAddress);

                var genParamEntries = new DynamicArray<GenericParameter>();

                using (var mdBuilder = m_metadataContext.getMetadataBuilder()) {
                    for (int i = 0; i < typeBuilders.length; i++)
                        typeBuilders[i].writeTypeMetadata(mdBuilder.value, tokenMap);
                    for (int i = 0; i < typeBuilders.length; i++)
                        typeBuilders[i].writeMethodImplEntries(mdBuilder.value, tokenMap);
                }

                for (int i = 0; i < typeBuilders.length; i++)
                    typeBuilders[i].appendGenParamEntries(tokenMap, ref genParamEntries);

                m_metadataContext.emitMethodSpecTable(tokenMap);
                _sortAndWriteGenParamEntries(ref genParamEntries);

                ilStream = new BlobBuilder(currentMethodBodyAddress);

                for (int i = 0; i < typeBuilders.length; i++)
                    typeBuilders[i].writeMethodBodies(ilStream, tokenMap);
            }

            BlobBuilder peFileBlob = new BlobBuilder();
            MethodDefinitionHandle entryPoint = default;
            if (!m_entryPoint.IsNil)
                entryPoint = (MethodDefinitionHandle)tokenMap.getMappedHandle(m_entryPoint);

            using (var mdBuilder = m_metadataContext.getMetadataBuilder()) {
                var metadataRootBuilder = new MetadataRootBuilder(mdBuilder.value, null, true);
                var peHeader = m_peHeader ?? new PEHeaderBuilder(Machine.I386);
                var peBuilder = new ManagedPEBuilder(peHeader, metadataRootBuilder, ilStream, entryPoint: entryPoint);
                peBuilder.Serialize(peFileBlob);
            }

            return new AssemblyBuilderEmitResult(peFileBlob.ToArray(), tokenMap);
        }

        private void _sortAndWriteGenParamEntries(ref DynamicArray<GenericParameter> entriesList) {
            if (entriesList.length == 0)
                return;

            var entries = entriesList.asReadOnlyArrayView();

            var codedIndexKeys = new int[entries.length];
            for (int i = 0; i < entries.length; i++)
                codedIndexKeys[i] = CodedIndex.TypeOrMethodDef(entries[i].ownerHandle);

            Array.Sort(codedIndexKeys, entriesList.getUnderlyingArray(), 0, entriesList.length);

            using var mdBuilder = m_metadataContext.getMetadataBuilder();

            for (int i = 0; i < entries.length; i++) {
                ref readonly var genParam = ref entries[i];
                StringHandle nameHandle = m_metadataContext.getStringHandle(genParam.name);

                var genParamHandle = mdBuilder.value.AddGenericParameter(
                    genParam.ownerHandle, genParam.attributes, nameHandle, genParam.position);

                ReadOnlySpan<EntityHandle> constraints = genParam.getConstraints().asSpan();
                for (int j = 0; j < constraints.Length; j++)
                    mdBuilder.value.AddGenericParameterConstraint(genParamHandle, constraints[j]);
            }
        }

    }

}
