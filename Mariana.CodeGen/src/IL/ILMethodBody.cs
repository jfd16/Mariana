using System;
using System.Reflection.Emit;
using System.Reflection.Metadata;
using Mariana.Common;

using static System.Buffers.Binary.BinaryPrimitives;

namespace Mariana.CodeGen.IL {

    /// <summary>
    /// Represents a method body generated by an <see cref="ILBuilder"/> instance.
    /// </summary>
    public sealed class ILMethodBody {

        private static readonly byte[] s_emptyLocalSig = { 7, 0 };

        private readonly bool m_useFatHeader;

        private readonly bool m_initLocals;

        private readonly ushort m_maxStack;

        private readonly byte[] m_localSignature;

        private readonly int m_localSignatureToken;

        private readonly byte[] m_methodBody;

        private readonly byte[] m_ehSection;

        private readonly int[] m_virtualTokenLocations;

        private readonly int m_totalLength;

        internal ILMethodBody(
            ushort maxStack,
            bool initLocals,
            byte[]? localSignature,
            int localSignatureToken,
            byte[]? methodBody,
            byte[]? ehSection,
            int[]? virtualTokenLocations
        ) {
            m_initLocals = initLocals;
            m_maxStack = maxStack;
            m_localSignature = localSignature ?? Array.Empty<byte>();
            m_localSignatureToken = localSignatureToken;
            m_methodBody = methodBody ?? Array.Empty<byte>();
            m_ehSection = ehSection ?? Array.Empty<byte>();
            m_virtualTokenLocations = virtualTokenLocations ?? Array.Empty<int>();
            m_useFatHeader = initLocals || localSignatureToken != 0 || maxStack > 8 || m_methodBody.Length >= 64 || m_ehSection.Length != 0;
            m_totalLength = _computeTotalLength();
        }

        /// <summary>
        /// Returns the maximum allowed height of the evaluation stack at any point of execution
        /// of the method code.
        /// </summary>
        public int maxStack => m_maxStack;

        /// <summary>
        /// Returns a value indicating whether local variables and memory allocated with the localloc instruction
        /// must be zero-initialized.
        /// </summary>
        public bool initLocals => m_initLocals;

        /// <summary>
        /// Returns a value indicating whether this method body requires a fat header.
        /// </summary>
        public bool hasFatHeader => m_useFatHeader;

        /// <summary>
        /// Returns the token for the method body's local signature. If there is no local signature, returns 0.
        /// </summary>
        public int localSignatureToken => m_localSignatureToken;

        /// <summary>
        /// Returns the length of the entire method body (including the header and any exception handling
        /// clauses) in bytes.
        /// </summary>
        public int byteLength => m_totalLength;

        /// <summary>
        /// Returns the binary local signature of the method body. If there is no local signature, an
        /// empty array is returned.
        /// </summary>
        public ReadOnlyArrayView<byte> getLocalSignature() => new ReadOnlyArrayView<byte>(m_localSignature);

        /// <summary>
        /// Returns the IL instruction stream of the method body.
        /// </summary>
        public ReadOnlyArrayView<byte> getCode() => new ReadOnlyArrayView<byte>(m_methodBody);

        /// <summary>
        /// Returns binary exception handling section of the method body. If there is no exception
        /// handling section, an empty array is returned.
        /// </summary>
        public ReadOnlyArrayView<byte> getExceptionSection() => new ReadOnlyArrayView<byte>(m_ehSection);

        /// <summary>
        /// Returns a list of byte offsets in the method's IL stream at which virtual tokens are
        /// located.
        /// </summary>
        public ReadOnlyArrayView<int> getVirtualTokenLocations() => new ReadOnlyArrayView<int>(m_virtualTokenLocations);

        /// <summary>
        /// Returns the length of the entire method body in bytes.
        /// </summary>
        private int _computeTotalLength() {
            int length = (m_useFatHeader ? 12 : 1) + m_methodBody.Length;

            if (m_ehSection.Length != 0) {
                if ((length & 3) != 0)
                    length = (length & ~3) + 4;
                length += m_ehSection.Length;
            }

            return length;
        }

        /// <summary>
        /// Writes the method body to the given <see cref="BlobBuilder"/>.
        /// </summary>
        /// <param name="blob">The <see cref="BlobBuilder"/> representing the byte stream into which the
        /// method body should be written.</param>
        /// <param name="tokenMapping">A <see cref="TokenMapping"/> instance to use for replacing
        /// virtual tokens with their corresponding real tokens. If this is null, virtual tokens
        /// are not replaced.</param>
        public void writeToBlobBuilder(BlobBuilder blob, TokenMapping? tokenMapping = null) {
            if (m_useFatHeader)
                blob.Align(4);

            Span<byte> span = blob.ReserveBytes(m_totalLength).GetBytes();
            writeToSpan(span, tokenMapping);
        }

        /// <summary>
        /// Writes the method body to the given span.
        /// </summary>
        /// <param name="span">A span representing the location in memory into which the
        /// method body should be written.</param>
        /// <param name="tokenMapping">A <see cref="TokenMapping"/> instance to use for replacing
        /// virtual tokens with their corresponding real tokens. If this is null, virtual tokens
        /// are not replaced.</param>
        public void writeToSpan(Span<byte> span, TokenMapping? tokenMapping = null) {
            int codeSize = m_methodBody.Length;

            if (m_useFatHeader) {
                ushort flags = 0x3;
                if (m_initLocals)
                    flags |= 0x10;
                if (m_ehSection.Length != 0)
                    flags |= 0x8;

                flags |= 0x3 << 12;

                WriteUInt16LittleEndian(span, flags);
                WriteUInt16LittleEndian(span.Slice(2), (ushort)maxStack);
                WriteInt32LittleEndian(span.Slice(4), codeSize);
                WriteInt32LittleEndian(span.Slice(8), m_localSignatureToken);

                span = span.Slice(12);
            }
            else {
                span[0] = (byte)((codeSize << 2) | 0x2);
                span = span.Slice(1);
            }

            m_methodBody.CopyTo(span);

            if (tokenMapping != null) {
                var vTokenLocations = m_virtualTokenLocations;
                for (int i = 0; i < vTokenLocations.Length; i++)
                    tokenMapping.patchToken(span.Slice(vTokenLocations[i]));
            }

            if (m_ehSection.Length != 0) {
                int alignment = ((codeSize & 3) != 0) ? 4 - (codeSize & 3) : 0;
                span = span.Slice(codeSize + alignment);
                m_ehSection.CopyTo(span);
            }
        }

        /// <summary>
        /// Returns a byte array containing the binary method body.
        /// </summary>
        /// <param name="tokenMapping">A <see cref="TokenMapping"/> instance to use for replacing
        /// virtual tokens with their corresponding real tokens. If this is null, virtual tokens
        /// are not replaced.</param>
        /// <returns>A byte array.</returns>
        public byte[] toByteArray(TokenMapping? tokenMapping = null) {
            byte[] arr = new byte[m_totalLength];
            writeToSpan(arr, tokenMapping);
            return arr;
        }

        /// <summary>
        /// Binds this method body to a method dynamically generated with the DynamicMethod
        /// API.
        /// </summary>
        /// <param name="dynamicILInfo">The <see cref="DynamicILInfo"/> for the dynamic method.</param>
        public void bindToDynamicILInfo(DynamicILInfo dynamicILInfo) {
            dynamicILInfo.SetCode(m_methodBody, m_maxStack);

            // DynamicILInfo requires a valid local signature, so use the empty signature
            // if there are no locals.
            dynamicILInfo.SetLocalSignature((m_localSignature.Length != 0) ? m_localSignature : s_emptyLocalSig);

            if (m_ehSection.Length != 0)
                dynamicILInfo.SetExceptions(m_ehSection);
        }

    }

}
